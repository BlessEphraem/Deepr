//// .includes.ahk
; Configuration file generated by main.py on 2025-11-10 17:34:35
#Requires AutoHotkey v2.0

; Final, absolute path to the JSON configuration file
path_settings := "Z:\Scripts\Deepr\.config\settings.json"

; Python command used to run scripts
cmd_python := "python"

; Final AHK script path
StartFinalScript := "Deepr.ahk"

; Specific structure variables (Can be expanded if needed)
AHK_ROOT_NAME := "Deepr"

; Configuration structure based on settings.json
class A_Path
{
    static rootDir := A_ScriptDir
    static Configuration := this.rootDir "\.config"
    static SupportFiles := this.rootDir "\SupportFiles"
    static AHK := this.SupportFiles "\AHK"
    static Icons := this.SupportFiles "\Icons"
    static Images := this.SupportFiles "\Images"
    static ImageSearch := this.SupportFiles "\ImageSearch"
    static Pythons := this.SupportFiles "\Pythons"
    static Sounds := this.SupportFiles "\Sounds"
    static Library := this.rootDir "\Library"
    static Core := this.Library "\Core"
    static Classes := this.Core "\Classes"
    static Functions := this.Core "\Functions"
    static GUIs := this.Library "\GUIs"
    static Modules := this.Library "\Modules"
    static Windows := this.Modules "\Windows"
    static PremierePro := this.Modules "\Premiere Pro"
    static AfterFx := this.Modules "\After Effects"

}

; ========================================
; --- AUTO-GENERATED SCRIPT INCLUDES ---
; ========================================

; --- 1. Global Includes (Always Active) ---


; --- Source: Deepr.Library.Core.Classes ---
#include "%A_ScriptDir%\Library\Core\Classes\Core_Settings.ahk"
#include "%A_ScriptDir%\Library\Core\Classes\Layouts_Class.ahk"

; --- Source: Deepr.Library.Core.Functions ---
#include "%A_ScriptDir%\Library\Core\Functions\JoinArray.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\Message.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\SearchCaret.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\SendInputControlFocusBack.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\TimedTooltip.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\WatchApp.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\WatchError.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\WatchModifierKeys.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\WatchMouse.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\WatchTooltip.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\fileNameConstructor.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\inputBox.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\keyWait.ahk"
#include "%A_ScriptDir%\Library\Core\Functions\sleepSend.ahk"

; --- Source: Deepr.Library.GUIs ---
#include "%A_ScriptDir%\Library\GUIs\Debug.ahk"
#include "%A_ScriptDir%\Library\GUIs\SideNote.ahk"
#include "%A_ScriptDir%\Library\GUIs\SuspendScriptGUI.ahk"

; --- Source: Deepr.Library.Modules.Windows ---
#include "%A_ScriptDir%\Library\Modules\Windows\Windows_Hotkeys.ahk"

; --- Source: Deepr.Library.Modules.Windows.Classes ---
#include "%A_ScriptDir%\Library\Modules\Windows\Classes\App_Class.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Classes\Files_Class.ahk"

; --- Source: Deepr.Library.Modules.Windows.Functions ---
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\AlwaysOnTop.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Application.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\ClassNN_toCoords.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\ClipCursor.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\FindCaret.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\HandleKeyGestures.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Komorebic.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Language.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Mouse.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Terminal.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Volume.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\WaitForUserConfirm.ahk"
#include "%A_ScriptDir%\Library\Modules\Windows\Functions\Window.ahk"

; --- 2. Context-Sensitive (HotIf) Includes ---


; --- Context: ahk_exe Adobe Premiere Pro.exe ---
#HotIf WinActive("ahk_exe Adobe Premiere Pro.exe")

; --- Source: Deepr.Library.Modules.PremierePro ---
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\PremierePro_Hotkeys.ahk"

; --- Source: Deepr.Library.Modules.PremierePro.Classes ---
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Classes\PremierePro_Attributes.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Classes\PremierePro_Class.ahk"

; --- Source: Deepr.Library.Modules.PremierePro.Functions ---
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\ApplyPreset.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\ClipClear.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\ClipGain.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Effects.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Keyframe.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Motion.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Panel.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Paste.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\Project.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\SendToAe.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\TrueCtrlBackspace.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\TrueFullscreen.ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\ValueEdit.Ahk"
#include "%A_ScriptDir%\Library\Modules\Premiere Pro\Functions\closeWin.ahk"
#HotIf ; End context ahk_exe Adobe Premiere Pro.exe

; --- Context: ahk_exe AfterFX.exe ---
#HotIf WinActive("ahk_exe AfterFX.exe")

; --- Source: Deepr.Library.Modules.AfterFx ---
#include "%A_ScriptDir%\Library\Modules\After Effects\AfterFX_Hotkeys.ahk"

; --- Source: Deepr.Library.Modules.AfterFx.Classes ---
#include "%A_ScriptDir%\Library\Modules\After Effects\Classes\AfterFX_Class.ahk"
#HotIf ; End context ahk_exe AfterFX.exe

#HotIf ; Final context reset

//// Deepr.ahk

/***********************************************************************************
 * 
 * @description A fully modulable ahk script with per application hotkeys layering.
 * @author Ephraem
 * @date 2021/05/10
 * @version 6.0 BETA (Trying with Python integration)
 * 
/**********************************************************************************/
/***********************************************************************************
                                        @Init
***********************************************************************************/

#include "%A_ScriptDir%\.includes.ahk"

    full_command_line := DllCall("GetCommandLine", "str")

    if not (A_IsAdmin or RegExMatch(full_command_line, " /restart(?!\S)")) {
        try {
            if A_IsCompiled 
                Run '*RunAs "' A_ScriptFullPath '" /restart'
            else
                Run '*RunAs "' A_AhkPath '" /restart "' A_ScriptFullPath '"'
        } ExitApp
    }

    TraySetIcon(A_Path.Icons "\deepr_Icon.png")

    if (PID := !ProcessExist("komorebi.exe"))
        Komorebic("start", &Result)
    
    #ESC::Run '*RunAs "' A_ScriptDir "\Launcher.ahk" '" /restart "' 

/***********************************************************************************
                                    @SetTimers
***********************************************************************************/

    global MsgboxTitle := "Deepr"
    global Err := MsgboxTitle " Error"

    g_AppsToPin := [
    "ahk_class ApplicationFrameWindow",
    "ahk_class CabinetWClass",
    Application_Class.MediaEncoder.winTitle
    ]

    g_childAppsToPin := [
        "Keyboard Shortcuts",
        "Track Fx Editor - ",
        "Clip Fx Editor - "
    ]
    
    SetTimer(WatchTooltip, 300)
    SetTimer(WatchError, 300)
    SetTimer((*) => WatchApp(g_AppsToPin, ), 300)
    SetTimer((*) => WatchChildApp(Application_Class.PremierePro.winTitle, g_childAppsToPin), 300)

   

;SetTimer((*) => RandomFunctions() , 1000)

/***********************************************************************************
                                        @GUI
***********************************************************************************/

    GUI_Debug.Init()
    SetTimer((*) => GUI_Debug.Update() , 100) ; Check every 100 ms
    GUI_SideNote.Init()


//// Launcher.ahk

#SingleInstance Force
class Files {
    static mainPy := "main.py"
    static inputHotkeys := {
        windows: "C:\Users\Ephraem\Desktop\Test_2\Hotkey_Window.ahk",
        premiere: "C:\Users\Ephraem\Desktop\Test_2\Hotkey_Premiere.ahk",
        afterfx: "C:\Users\Ephraem\Desktop\Test_2\Hotkey_AfterFx.ahk"
    }

    static outputIncludes := ".includes.ahk" 
}

; If one of thoses return false = Fatal Error
Launcher.Check.IsAdmin
Launcher.Check.Python(&pythonCmd)
Launcher.Check.mainPy(A_ScriptDir, Files.mainPy)
Launcher.Build(pythonCmd, Files.mainPy, Files.outputIncludes)
ExitApp

class Launcher {

    /**
     * Handles logging to a file and provides message box configuration.
     * The LogFile path is stored statically.
     */
    class Log {
        ; Define the path for the log file
        static LogFile := "launcher.log"

        ; Message box parameters: [Prefix, Title, Icon]
        static Err := ["Error : ", "Error", "16"]      ; Icon 16: Stop
        static FatErr := ["Fatal Error : ", "Fatal Error", "16"] ; Icon 16: Stop
        static Warn := ["Warning : ", "Read Warning", "48"]    ; Icon 48: Warning
        static Done := ["Done : ", "Done", "64"]      ; Icon 64: Information

        /**
        * Writes a formatted message to the log file.
        * @param {string} type - The message type (e.g., "ERROR", "WARNING", "INFO").
        * @param {string} msg - The content of the message.
        * @returns {void}
        */
        static Write(type, msg) {
            ; Format: [YYYY-MM-DD HH:MM:SS] [TYPE] Message content
            Timestamp := FormatTime(, "yyyy-MM-dd HH:mm:ss")
            LogEntry := "[" Timestamp "] [" type "] " msg "`n"
            try {
                FileAppend(LogEntry, Launcher.Log.LogFile)
            } catch {
                ; Cannot write to log file, maybe permission error. Fail silently.
            }
        }
    }

    class Check {

        /**
        * Checks if Python is installed and accessible via the PATH by trying common launchers.
        * Displays a message box whether Python is found or not.
        * @returns {void}
        */
        static Python(&foundCommand) {

            pythonCommands := ["python", "py", "python3"]
            foundCommand := ""
            pythonVersion := ""
            
            Launcher.Log.Write("INFO", "Starting Python check...")

            for cmd in pythonCommands { ; Try launching each check command
                Launcher.Log.Write("INFO", "Attempting to launch: " cmd " --version")
                try {
                    ; Note: RunWait does not capture stdout easily in AHK v2 without explicit redirection.
                    ; We'll assume successful execution signals Python is found.
                    cmdCompose := A_ComSpec " /c " cmd " --version"
                    Output := RunWait(cmdCompose, ,)
                    if (Output != "") { ; Output might contain the version string if redirection was used, or is just a success signal
                        foundCommand := cmd
                        Launcher.Log.Write("SUCCESS", "Python found via command: " foundCommand)
                        break ; Found, stop the loop
                    }
                } catch { ; Run failed (command not found, not in PATH) - Continue with the next command
                    Launcher.Log.Write("DEBUG", "Command '" cmd "' failed to launch or is not in PATH.")
                }
            }

            if (foundCommand != "") {
                ; The original script used the assumption that RunWait returned the version. We log success.
                resultTrue := " üêç Python Check OK" . "`n`nPython is installed and accessible via the command: " . foundCommand
                Launcher.Log.Write("DONE", resultTrue)
                return foundCommand
            } else {
                resultFalse := "Python not found" . "`n`nPython could not be launched with the common commands ('python', 'py', 'python3')."
                . "`n`nIf you are using modules that depend on Python, please ensure it is installed and its access path (PATH) is correctly configured."
                ; Added instruction to check log file
                . "`n`nFor more details, please check the log file: " . Launcher.Log.LogFile
                Launcher.Log.Write("FATAL_ERROR", resultFalse)
                MsgBox Launcher.Log.FatErr[1] resultFalse, Launcher.Log.FatErr[2], Launcher.Log.FatErr[3]
                return foundCommand := false
            }
        }

        static mainPy(path_ScriptDir, StartScript) {
            ScriptLocation := path_ScriptDir "\" StartScript
            if !FileExist(ScriptLocation) {
                errorMsg := "The Python script '" StartScript "' was not found in the folder '" A_ScriptDir "'"
                Launcher.Log.Write("FATAL_ERROR", errorMsg)
                MsgBox Launcher.Log.FatErr[1] errorMsg . "`n`nCheck the log file: " . Launcher.Log.LogFile,
                Launcher.Log.FatErr[2], Launcher.Log.FatErr[3]
                ExitApp
            } else {
                Launcher.Log.Write("INFO", "Python script found at: " ScriptLocation)
                return ScriptLocation
            }
        }

        /**
        * Ensures the script is running with administrator privileges.
        * Restarts the script using RunAs if not already running as Admin or with /restart.
        * @returns {void}
        */
        static IsAdmin()
        {
            full_command_line := DllCall("GetCommandLine", "str")
            if not (A_IsAdmin or RegExMatch(full_command_line, " /restart(?!\S)")) {
                try {
                    Launcher.Log.Write("WARNING", "Attempting automatic restart as administrator...")
                    warnMsg := "Automatic restart as administrator.."
                    
                    ; Added instruction to check log file
                    msgBoxText := warnMsg . "`n`nCheck the log file: " . Launcher.Log.LogFile

                    if A_IsCompiled {
                        MsgBox Launcher.Log.Warn[1] msgBoxText, Launcher.Log.Warn[2], Launcher.Log.Warn[3]
                        Run '*RunAs "' A_ScriptFullPath '" /restart'
                    }
                    else {
                        MsgBox Launcher.Log.Warn[1] msgBoxText, Launcher.Log.Warn[2], Launcher.Log.Warn[3]
                        Run '*RunAs "' A_AhkPath '" /restart "' A_ScriptFullPath '"'
                    }
                }
                ExitApp
            }
            Launcher.Log.Write("INFO", "Script is running with appropriate permissions (Admin or no restart needed).")
        }

        static REGEDIT(RegPath := "", ExpectedValue := "") {
            Launcher.Log.Write("INFO", "Checking registry path: " RegPath " for expected value: " ExpectedValue)
            try { ; Read the registry value
                ActualValue := RegRead(RegPath)
                if (ActualValue == ExpectedValue) {
                    resultTrue := "Deactivation OK" . "`n`nThe registry key for the Office Key is correctly configured (" . RegPath . " = " . ActualValue . ")."
                    . "`n The risk of triggering Office is low."
                    Launcher.Log.Write("DONE", resultTrue)
                    return true
                } else {
                    resultFalse := "Office Key Active" . "`n`nThe registry key is currently: " . ActualValue
                    . "`n`nIt must be modified to avoid conflict with complex shortcuts (Win+Shift+Alt). "
                    . "`n`nThis will open the page https://m365.cloud.microsoft/?from=OfficeKey if you are not careful.`n`n"
                    . "`n`nYou should run the following command:`n`n" . "REG ADD " . RegPath . " /t REG_SZ /d " . ExpectedValue
                    ; Added instruction to check log file
                    msgBoxText := resultFalse . "`n`nCheck the log file: " . Launcher.Log.LogFile
                    Launcher.Log.Write("WARNING", resultFalse)
                    msgbox Launcher.Log.Warn[1] msgBoxText, Launcher.Log.Warn[2], Launcher.Log.Warn[3]
                    return false
                }
            } catch as e {
                ; Read error, most likely because the key/value does not exist.
                errorMsg := "Registry Read Error: " e.Message . "`nCould not read key: " RegPath
                . "`n`nThis usually means the Office Key is active or the key structure is different."
                resultFalse := "Office Key Active" . "`n`nIt must be modified to avoid conflict with complex shortcuts (Win+Shift+Alt). "
                . "`n`nThis will open the page https://m365.cloud.microsoft/?from=OfficeKey if you are not careful.`n`n"
                . "`n`nYou should run the following command:`n`n" . "REG ADD " . RegPath . " /t REG_SZ /d " . ExpectedValue
                ; Added instruction to check log file
                msgBoxText := resultFalse . "`n`nCheck the log file: " . Launcher.Log.LogFile
                Launcher.Log.Write("WARNING", errorMsg . "`nAction Required: " resultFalse)
                msgbox Launcher.Log.Warn[1] msgBoxText, Launcher.Log.Warn[2], Launcher.Log.Warn[3]
                return false
            }
        }
    }

    static Build(pythonCmd, StartScript, OutputDir) {
        Launcher.Log.Write("INFO", "Starting Build process.")
        Launcher.Log.Write("INFO", "Command: " pythonCmd " " StartScript " build " pythonCmd " " OutputDir)

        ; RunWait returns the exit code of the launched program
        ; Passing pythonCmd as an argument to the Python script to save it in "path.ini" for easier reuse later
        ; Use the StartScript variable if you implement Python detection (see Python() function below)
        exitCode := RunWait(pythonCmd " " StartScript " build " pythonCmd " " OutputDir, , "Hide")
        
        Launcher.Log.Write("INFO", "Build script finished with Exit Code: " exitCode)

        if (exitCode = 0) {
            try {
                
                FileRead(StartScript) ; Reading the raw content of the INI file
                
                successMsg := "Configuration Successful!" . "`n`nThe Python script finished successfully and generated 'path.ini'."
                Launcher.Log.Write("DONE", successMsg)
                return
            } catch as e {
                errorMsg := "The Python script succeeded (Code: 0), but the file " StartScript " could not be read."
                . "`n`nError: " e.Message
                ; Added instruction to check log file
                msgBoxText := errorMsg . "`n`nCheck the log file: " . Launcher.Log.LogFile
                Launcher.Log.Write("FATAL_ERROR", errorMsg)
                MsgBox Launcher.Log.FatErr[1] msgBoxText, Launcher.Log.FatErr[2], Launcher.Log.FatErr[3]
                ExitApp
            }
        } else {
            errorMsg := "Configuration Failure!" . "`n`nThe Python script encountered an error or was canceled by the user. Exit code: " exitCode
            . "`nThe operation is canceled."
            ; Added instruction to check log file
            msgBoxText := errorMsg . "`n`nCheck the log file: " . Launcher.Log.LogFile
            Launcher.Log.Write("FATAL_ERROR", errorMsg)
            MsgBox Launcher.Log.FatErr[1] msgBoxText, Launcher.Log.FatErr[2], Launcher.Log.FatErr[3]
            ExitApp
        }
        return
    }
}


//// Core_Settings.ahk

#Requires AutoHotkey v2.0

#SingleInstance force
Persistent
InstallKeybdHook
InstallMouseHook
#UseHook
SendMode "Input"
/*
    Very important too, we need a better control of our computer and input, "InstallKeybdHook" il really needed
    for the alt-menu accelleration, and SendMode "Input" is just better. No need an explanation here, just
    use SendMode "Input" in your script, you will have a better control.
*/

#WinActivateForce ; For Faster response. Used for "\lib\Modules\Windows\Class\ApplicationClass.ahk" and "\Functions\WindowMover.ahk"

;false is the default settings, but I put it because it's very important.
;If you put it on, the class "Application" will no longer work. It can Run/Focus/Minimize an app.
DetectHiddenWindows false

SetWinDelay 2
SetKeyDelay 0, 2
SetMouseDelay 0
SetControlDelay 0
A_HotkeyInterval := 0

//// fileNameConstructor.ahk

FileNameConstructor(Params*) {
    fileName := ""
    for each, part in Params
        fileName .= part
    return fileName
}

//// inputBox.ahk

MyInputBox() {
	IB := InputBox("Please enter a value."), UserInput := IB.Value, ErrorLevel := IB.Result="OK" ? 0 : IB.Result="CANCEL" ? 1 : IB.Result="Timeout" ? 2 : "ERROR"
	if ErrorLevel {
		MsgBox("CANCEL was pressed.")
		Exit()
	}
	else {
		return UserInput
	}
}

//// JoinArray.ahk

JoinArray(arr, sep := " / ") {
    ; Initializes the output string to be built.
    out := ""
    
    ; Iterates over the array elements. 'i' is the 1-based index (key), 'val' is the value.
    for i, val in arr {
        ; Appends the separator *before* the current value, but only if it's not the first element (i > 1).
        ; This is a common pattern to avoid a trailing separator.
        out .= (i > 1 ? sep : "") val
    }
    ; Returns the final joined string.
    return out
}



//// SearchCaret.ahk

SearchCaret(control := "A", Duration := 3000) {
    local maxTime := A_TickCount + Duration
    
    ; Tenter de trouver le focus sur 'Edit1' (la barre d'adresse) pendant la dur√©e sp√©cifi√©e.
    while (A_TickCount < maxTime) {
        if (ControlGetFocus("A") == control) {
            return true ; Focus trouv√©
        }
        Sleep 50 ; Petite pause pour ne pas surcharger le processeur
    }
    
    return false ; Focus non trouv√© dans le d√©lai imparti
}

//// SendInputControlFocusBack.ahk

SendInputControlFocusBack(Hotkeys, WhichPanel) {
    Controls := ControlGetFocus("A")
    SendInput WhichPanel
    sleep 10
    ; V√©rifie si Hotkeys est un array
    if Type(Hotkeys) = "Array" {
        for Each, Key in Hotkeys {
            SendInput Key
            Sleep 50
        }
    } else {
        ; Si ce n'est pas un array, l'utiliser comme une seule cha√Æne
        SendInput Hotkeys
        Sleep 50
    }

    ControlFocus Controls
}

//// WatchApp.ahk

#Requires AutoHotkey v2.0

WatchApp(g_AppsToPin) {

    ; On boucle sur chaque √©l√©ment (chaque crit√®re)
    ; contenu dans notre tableau g_AppsToPin.
    for winCriterion in g_AppsToPin
    {
        ; 1. V√©rifier si une fen√™tre correspondante existe.
        ; WinExist() renvoie l'ID unique (HWND) de la premi√®re
        ; fen√™tre trouv√©e, ou 0 si aucune fen√™tre ne correspond.
        hwnd := WinExist(winCriterion)

        ; 2. Si la fen√™tre existe (hwnd n'est pas 0)...
        if (hwnd)
        {
            ; 3. On v√©rifie son "style √©tendu" (ExStyle).
            ; Le style "Always on Top" (WS_EX_TOPMOST)
            ; correspond √† la valeur hexad√©cimale 0x8.
            currentStyle := WinGetExStyle("ahk_id " hwnd)

            ; 4. On v√©rifie si le style 0x8 n'est PAS d√©j√† appliqu√©.
            ; L'op√©rateur "&" (ET binaire) v√©rifie si le "bit"
            ; 0x8 est "allum√©" dans currentStyle.
            ; On met un "!" (NON) devant pour agir
            ; seulement si ce n'est PAS le cas.
            if !(currentStyle & 0x8)
            {
                ; 5. La fen√™tre existe mais n'est pas "On Top".
                ; On la met donc en "Always on Top" !
                WinSetAlwaysOnTop(1, "ahk_id " hwnd)
            }
        }
        ; Si (hwnd) est 0 (faux), la fen√™tre n'existe pas,
        ; donc on ne fait rien et on passe √† l'√©l√©ment suivant.
    }
}

#Requires AutoHotkey v2.0

/**
 * WatchChildApp - Cherche une fen√™tre enfant par titre et v√©rifie son crit√®re AHK parent.
 *
 * @param {String} ahkCriteria - Le crit√®re AHK √† v√©rifier pour la fen√™tre enfant trouv√©e
 * (ex: "ahk_exe Premiere Pro.exe").
 * @param {Array} childTitles - Un tableau de titres de fen√™tre √† rechercher (ex: ["Track Fx Editor - ", "Keyboard Shortcuts"]).
 */
WatchChildApp(ahkCriteria, childTitles) {
    ; Afficher pour le debug.

    ; On boucle sur chaque titre de fen√™tre enfant √† rechercher.
    for childTitle in childTitles
    {
        ; 1. Chercher la fen√™tre enfant par son titre exact (match partiel si le titre se termine par ' - ').
        ; La fonction WinExist utilise le mode AHK_TITLE_MATCH_MODE par d√©faut (2 - contient).
        ; On utilise le titre seul ici, car AHK va chercher la fen√™tre qui match CE titre en premier.
        ; On ajoute 'ahk_class' pour ne pas affecter la recherche par titre, mais pour le debug
        ; on pourrait utiliser 'ahk_id' plus tard pour cibler pr√©cis√©ment.
        local hwnd := WinExist(childTitle)

        ; Afficher l'√©tat de la recherche pour le debug.
        if (hwnd) {

            ; 2. Si la fen√™tre enfant existe (hwnd n'est pas 0)...
            ; On v√©rifie maintenant si elle correspond au crit√®re AHK fourni (ahkCriteria).
            ; Ceci v√©rifie si le processus parent/propri√©taire est le bon.
            ; On concat√®ne le ahk_id pour s'assurer que WinExist utilise CETTE fen√™tre sp√©cifique pour la v√©rification.
            if (WinExist("ahk_id " hwnd " " ahkCriteria))
            {

                ; 3. On v√©rifie son "style √©tendu" (ExStyle).
                ; Le style "Always on Top" (WS_EX_TOPMOST) correspond √† la valeur hexad√©cimale 0x8.
                local currentStyle := WinGetExStyle("ahk_id " hwnd)

                ; 4. On v√©rifie si le style 0x8 n'est PAS d√©j√† appliqu√©.
                ; L'op√©rateur "&" (ET binaire) v√©rifie si le "bit" 0x8 est "allum√©" dans currentStyle.
                if !(currentStyle & 0x8)
                {
                    ; 5. La fen√™tre enfant existe, match le crit√®re, et n'est pas "On Top".
                    ; On la met donc en "Always on Top" !
                    WinSetAlwaysOnTop(1, "ahk_id " hwnd)
                    ; On sort de la boucle d√®s qu'une fen√™tre enfant correspondante est trouv√©e et trait√©e.
                    return
                } else {
                    ; La fen√™tre est d√©j√† "On Top", on peut s'arr√™ter aussi.
                    return
                }
            } else {
                ; Fen√™tre trouv√©e, mais le crit√®re AHK ne correspond pas (pas le bon parent).
                ToolTip("WatchChildApp: Fen√™tre trouv√©e (" childTitle . ") mais le crit√®re AHK ne correspond pas. Ignor√©.", 10, A_ScreenHeight - 60, 2000)
            }
        }
    }
    ; Si aucune fen√™tre enfant n'est trouv√©e apr√®s la boucle, on affiche un message.
}

//// WatchError.ahk

WatchError() {
    ; V√©rifie s'il y a une MsgBox avec le titre "Erreur"
    if WinExist(Err) {
        ; D√©bloque tout
        try BlockInput("Off")
        try BlockInput("MouseMoveOff")
        try BlockInput("SendOff")

        ; (Optionnel) Affiche un message discret pour confirmer
        ToolTip "üí° S√©curit√© : BlockInput d√©sactiv√© automatiquement.", 100, 100
        SetTimer(() => ToolTip(), -2000) ; cache le tooltip apr√®s 2s
    }
}

//// WatchModifierKeys.ahk

WatchModifierKeys() {

    modifierKeys := [
        "LAlt",
        "LCtrl",
        "LShift",
        "LWin",
        "RAlt",
        "RCtrl",
        "RShift",
        "RWin"
    ]

    for key in modifierKeys {
        ; √âtat logique = ce que le syst√®me croit
        logicalDown := GetKeyState(key)
        ; √âtat physique = ce que ton clavier envoie r√©ellement
        physicalDown := GetKeyState(key, "P")

        ; Si le syst√®me pense que la touche est enfonc√©e,
        ; mais que physiquement elle est rel√¢ch√©e :
        if (logicalDown && !physicalDown) {
            Send "{" key " up}"
            ToolTip key " lib√©r√©e (correction Alt bloqu√©)"
            SetTimer () => ToolTip(""), -1000  ; Cache le tooltip apr√®s 1s
        }
    }
}

//// WatchMouse.ahk

#Requires AutoHotkey v2.0

WatchMouse()
{
    MouseGetPos , , &WindowUnderMouse, &ControlUnderMouse

    try ProcessNameHWND := WinGetProcessName("A") 
    ClassHWND := " ahk_class " WinGetClass(WindowUnderMouse)
    ControlHWND := " Control: " ControlUnderMouse

    Text := ProcessNameHWND "|" ClassHWND "|" ControlHWND  ; Regrouper les donn√©es dans une seule variable s√©par√©e par "|"

    WatchMouse_Tooltip(Text, "Off")
}

WatchMouse_Tooltip(Text, OnOff) {
    if (OnOff = "Off") {
        ToolTip  ; Efface la ToolTip si "Off"
        return
    }
    
    lines := StrSplit(Text, "|")  ; D√©composer la variable en une liste
    formattedText := ""
    
    for index, line in lines {
        formattedText .= line
        if (index < lines.Length) {
            formattedText .= " `n "  ; Ajouter un saut de ligne sauf pour le dernier √©l√©ment
        }
    }
    
    ToolTip formattedText  ; Afficher la ToolTip avec le texte format√©
}



//// WatchTooltip.ahk

#Requires AutoHotkey v2.0

; --- Tooltip Watchdog ---
global TooltipActive := false
global TooltipStart := 0
global TooltipTimeout := 5000


; Fonction de surveillance
WatchTooltip() {
    global TooltipActive, TooltipStart, TooltipTimeout
    tooltipWin := WinExist("ahk_class tooltips_class32") ; V√©rifie s'il y a un tooltip
    ; Si un tooltip est visible
    if tooltipWin {
        if !TooltipActive {
            TooltipActive := true
            TooltipStart := A_TickCount
        } else if (A_TickCount - TooltipStart >= TooltipTimeout) {
            ; Supprime le tooltip en le cachant
            tooltip
            TooltipActive := false
        }
    } else {
        TooltipActive := false
    }
}

//// Debug.ahk

#Requires AutoHotkey v2.0
#SingleInstance Force

; Array: [Line1 (Hotkey/Trigger), Line2 (Function/Result), Ping (Force GUI update)]
global ReturnDebug := ['', '', false] 


; Original from Taran Van Hemert, big thanks for his AHK 1.0 (https://github.com/TaranVH/2nd-keyboard/blob/master/Taran's_Windows_Mods/KEYSTROKE_VIZ.ahk)
; Adapted for AHK v2.0.
class GUI_Debug
{

    static CurrentState := ['', '', false] ; [Line1, Line2, Ping]

    /**
     * @static
     * Public interface for hotkeys to set the new state.
     * @param Line1 The hotkey/trigger text.
     * @param Line2 The function/result text.
     * @param Ping If true, forces a GUI shift.
     */
    static ReturnDebug(A_Line1, A_Line2, A_Ping := false) {
        ; Met √† jour la propri√©t√© statique interne
        GUI_Debug.CurrentState := [A_Line1, A_Line2, A_Ping]
    }

    ;
    ; --- STATIC PROPERTIES FOR CONFIGURATION AND CONTROLS ---
    static G_MAIN := unset ; The main GUI (will be initialized in .Init())
    static IsVisible := true
    static ShowInAltTabOnVisible := false

    ; --- GLOBAL HISTORY PROPERTIES (New addition) ---
    ; Used to store the current values and the last-updated values for change detection.
    ; Stocke la derni√®re valeur lue de ReturnDebug pour la comparaison.
    static HISTORY_STATE_OLD := ['', '', false] 

    ;
    ; Move all configuration constants from the start of the script here
    ; Make them static

    ; --- MONITOR AND LOCATION CONFIGURATION ---
    static MONITOR_INDEX := 2
    static LOCATION := 3

    ;
    ; --- COLORS ---
    static GUI_BG_COLOR := '121212'
    static GUI_TEXT_COLOR_DEFAULT := 'ffffff'
    static HISTORY_COLOR_2 := 'ff0000'
    static HISTORY_COLOR_1 := 'ffe600'
    static HISTORY_COLOR_0 := '00ff62'

   ;
    ; --- DIMENSIONS AND POSITIONING ---
    static MAIN_TEXT_SIZE := 24
    static MAIN_TEXT_WEIGHT := 400
    static DETAIL_TEXT_SIZE := 16
    
    static DETAIL_TEXT_WEIGHT := 200

    static MAIN_TEXT_CONTROL_HEIGHT := GUI_Debug.MAIN_TEXT_SIZE * 2
    static DETAIL_TEXT_CONTROL_HEIGHT := GUI_Debug.DETAIL_TEXT_SIZE * 2
    static DETAIL_TEXT_OFFSET_Y := GUI_Debug.MAIN_TEXT_CONTROL_HEIGHT + 5
    static GUI_LINE_SINGLE_HEIGHT := GUI_Debug.MAIN_TEXT_CONTROL_HEIGHT + GUI_Debug.DETAIL_TEXT_CONTROL_HEIGHT + 10

    static GUI_WIDTH := 1200
    static SCREEN_MARGIN_EDGE := 16
    static GUI_VERTICAL_GAP := 10

    static APPLICATION_NAME := 'KEYSTROKE_VIZ'


    ; Calculate the necessary height for a single history line
    static GUI_HEIGHT := (GUI_Debug.GUI_LINE_SINGLE_HEIGHT * 3) + (GUI_Debug.GUI_VERTICAL_GAP * 2)

    ;
    ; --- TRANSPARENCY ---
    static HISTORY_ALPHA_0 := 225
    static HISTORY_ALPHA_1 := 225
    static HISTORY_ALPHA_2 := 160

    ;
    ; --- CONSOLIDATED FONT PROPERTIES ---
    static MAIN_TEXT_FONT_FAMILY := 'Satoshi Light'
    static MAIN_FONT_PROPS := 'S' GUI_Debug.MAIN_TEXT_SIZE ' W' GUI_Debug.MAIN_TEXT_WEIGHT ' Q5 norm'

    static DETAIL_TEXT_FONT_FAMILY := 'Satoshi Light'
    static DETAIL_FONT_PROPS := 'S' GUI_Debug.DETAIL_TEXT_SIZE ' W' GUI_Debug.DETAIL_TEXT_WEIGHT ' Q5 norm'


    /**
     * @static
     * Initializes and shows the debug GUI.
     */
    static Init() {
        ;
        ; --- MONITOR SELECTION AND COORDINATE CALCULATION (UNCHANGED) ---
        try {
            MonitorGet(GUI_Debug.MONITOR_INDEX + 1, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
        } catch {
            MonitorGet(0, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
        }
    
        if (MonitorRight == '') {
            MaxMonitorIndex :=
            0
            while MonitorGet(MaxMonitorIndex + 1, &temp1)
            MaxMonitorIndex++
            
            UseMonitorIndex := MaxMonitorIndex - 1
            MonitorGet(UseMonitorIndex + 1, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
        }
        else {
            UseMonitorIndex := GUI_Debug.MONITOR_INDEX
        }

        ; SCREEN_WIDTH := MonitorRight - MonitorLeft
        ; SCREEN_HEIGHT := MonitorBottom - MonitorTop
    
        if (GUI_Debug.LOCATION = 1 or GUI_Debug.LOCATION = 3)
            GUI_X := MonitorLeft + GUI_Debug.SCREEN_MARGIN_EDGE
        else
            GUI_X := MonitorRight - GUI_Debug.GUI_WIDTH - GUI_Debug.SCREEN_MARGIN_EDGE
    
        if (GUI_Debug.LOCATION = 1 or GUI_Debug.LOCATION = 2)
            GUI_Y := MonitorTop + GUI_Debug.SCREEN_MARGIN_EDGE
        
        else
            GUI_Y := MonitorBottom - GUI_Debug.GUI_HEIGHT - GUI_Debug.SCREEN_MARGIN_EDGE
    
        ;
        ; --- SINGLE GUI CREATION (UNCHANGED) ---
        static GUI_OPTIONS := '+Owner +AlwaysOnTop -Resize -SysMenu -MinimizeBox -MaximizeBox -Disabled -Caption -Border'

        GUI_Debug.G_MAIN := Gui()
        GUI_Debug.G_MAIN.Opt(GUI_OPTIONS)
        GUI_Debug.G_MAIN.MarginX := 0
        GUI_Debug.G_MAIN.MarginY := 0
        GUI_Debug.G_MAIN.BackColor := GUI_Debug.GUI_BG_COLOR
        GUI_Debug.G_MAIN.Title := GUI_Debug.APPLICATION_NAME
    
        ;
        ; Calculate Y-Coordinates within the single GUI
        LINE2_START_Y := 0
        LINE1_START_Y := LINE2_START_Y + GUI_Debug.GUI_LINE_SINGLE_HEIGHT + GUI_Debug.GUI_VERTICAL_GAP
        LINE0_START_Y := LINE1_START_Y + GUI_Debug.GUI_LINE_SINGLE_HEIGHT + GUI_Debug.GUI_VERTICAL_GAP
    
        ;
        ; --- HISTORY2 (Oldest line - Red/Alpha 2) ---
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.HISTORY_COLOR_2 ' ' GUI_Debug.MAIN_FONT_PROPS, GUI_Debug.MAIN_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine2_Text x0 y' LINE2_START_Y ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.MAIN_TEXT_CONTROL_HEIGHT, ' ') ; Initial empty text
        
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.GUI_TEXT_COLOR_DEFAULT ' ' GUI_Debug.DETAIL_FONT_PROPS, GUI_Debug.DETAIL_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine2_Name x0 y' (LINE2_START_Y + GUI_Debug.DETAIL_TEXT_OFFSET_Y) ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.DETAIL_TEXT_CONTROL_HEIGHT, ' ')
    
    
        ;
        ; --- HISTORY1 (Recent line - Yellow/Alpha 1) ---
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.HISTORY_COLOR_1 ' ' GUI_Debug.MAIN_FONT_PROPS, GUI_Debug.MAIN_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine1_Text x0 y' LINE1_START_Y ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.MAIN_TEXT_CONTROL_HEIGHT, ' ')
        
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.GUI_TEXT_COLOR_DEFAULT ' ' GUI_Debug.DETAIL_FONT_PROPS, GUI_Debug.DETAIL_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine1_Name x0 y' (LINE1_START_Y + GUI_Debug.DETAIL_TEXT_OFFSET_Y) ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.DETAIL_TEXT_CONTROL_HEIGHT, ' ')
    
    
        ;
        ; --- HISTORY0 (Current line - Green/Alpha 0) ---
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.HISTORY_COLOR_0 ' ' GUI_Debug.MAIN_FONT_PROPS, GUI_Debug.MAIN_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine0_Text x0 y' LINE0_START_Y ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.MAIN_TEXT_CONTROL_HEIGHT, ' ')
        
        GUI_Debug.G_MAIN.SetFont('C' GUI_Debug.GUI_TEXT_COLOR_DEFAULT ' ' GUI_Debug.DETAIL_FONT_PROPS, GUI_Debug.DETAIL_TEXT_FONT_FAMILY)
        GUI_Debug.G_MAIN.AddText('vLine0_Name x0 y' (LINE0_START_Y + GUI_Debug.DETAIL_TEXT_OFFSET_Y) ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.DETAIL_TEXT_CONTROL_HEIGHT, ' ')
    
        GUI_Debug.G_MAIN.Show('x' GUI_X ' y' GUI_Y ' w' GUI_Debug.GUI_WIDTH ' h' GUI_Debug.GUI_HEIGHT ' NoActivate' (GUI_Debug.IsVisible ? '' : ' Hide'))

        ; Apply transparency (TransColor for the whole GUI)
        WinSetTransColor(GUI_Debug.GUI_BG_COLOR, GUI_Debug.APPLICATION_NAME)
    }


    /**
     * @static
     * Toggles the visibility of the debug GUI. (UNCHANGED)
     * - Hides the window completely (WinHide).
     * - Manages Alt+Tab visibility using +ToolWindow/+AppWindow based on ShowInAltTabOnVisible.
     * @return {boolean} True if the GUI is now visible, False if hidden.
     */
    static Toggle() {
        ; Checks if the GUI has been initialized
        if (!IsObject(GUI_Debug.G_MAIN)) {
            return
        }

        ; 1. Inverser l'√©tat de visibilit√©
        GUI_Debug.IsVisible := !GUI_Debug.IsVisible

        if (GUI_Debug.IsVisible) {
            ; --- RENDRE VISIBLE ---

            ; Si ShowInAltTabOnVisible est true, on remet +AppWindow pour qu'elle apparaisse dans Alt+Tab
            if (GUI_Debug.ShowInAltTabOnVisible) {
                GUI_Debug.G_MAIN.Opt('-ToolWindow')
            } else {
                ; Sinon, elle reste +ToolWindow (d√©j√† appliqu√© dans Init)
                ; On s'assure qu'elle est en mode +ToolWindow
                GUI_Debug.G_MAIN.Opt('+ToolWindow')
            }

            ; Afficher la fen√™tre
            WinShow(GUI_Debug.APPLICATION_NAME)
            WinSetTransColor(GUI_Debug.GUI_BG_COLOR, 'ahk_id ' GUI_Debug.G_MAIN.Hwnd)
            return True

        } else {
            ; --- RENDRE INVISIBLE ---

            ; On applique +ToolWindow (cach√© d'Alt+Tab) si ce n'est pas d√©j√† le cas.
            WinSetTransColor('', 'ahk_id ' GUI_Debug.G_MAIN.Hwnd)
            GUI_Debug.G_MAIN.Opt('+ToolWindow')

            ; Cacher la fen√™tre compl√®tement
            WinHide(GUI_Debug.APPLICATION_NAME)
            return False
        }
    }


    /**
     * @static
     * Updates the content of the visualization window. (UNCHANGED - used by hotkeys directly)
     * @param TEXT_LINE2 Content of the second line (The function name/result).
     * @param TEXT_LINE1 Content of the first line (The hotkey/trigger).
     * @param A_ForceShift (Optional) If true, forces an extra shift up.
     */
    static UpdateGui(TEXT_LINE2, TEXT_LINE1, A_ForceShift := false) {
        ; Checks if the GUI has been initialized
        if (!IsObject(GUI_Debug.G_MAIN)) {
            return
        }

        ; --- LOGIQUE DE D√âCALAGE DEMAND√âE PAR LE PING ---
        if (A_ForceShift) {
            ; Shift: HISTORY2 takes the content of HISTORY1 (shift up)
            GUI_Debug.G_MAIN['Line2_Text'].Value := GUI_Debug.G_MAIN['Line1_Text'].Value
            GUI_Debug.G_MAIN['Line2_Name'].Value := GUI_Debug.G_MAIN['Line1_Name'].Value
            
            ; Shift: HISTORY1 takes the content of CURRENT (shift to middle)
            GUI_Debug.G_MAIN['Line1_Text'].Value := GUI_Debug.G_MAIN['Line0_Text'].Value
            GUI_Debug.G_MAIN['Line1_Name'].Value := GUI_Debug.G_MAIN['Line0_Name'].Value
        } else {
            ; 1. HISTORY2 takes the content of HISTORY1 (shift up)
            GUI_Debug.G_MAIN['Line2_Text'].Value := GUI_Debug.G_MAIN['Line1_Text'].Value
            GUI_Debug.G_MAIN['Line2_Name'].Value := GUI_Debug.G_MAIN['Line1_Name'].Value
            
            ; 2. HISTORY1 takes the content of CURRENT (shift to middle)
            GUI_Debug.G_MAIN['Line1_Text'].Value := GUI_Debug.G_MAIN['Line0_Text'].Value
            GUI_Debug.G_MAIN['Line1_Name'].Value := GUI_Debug.G_MAIN['Line0_Name'].Value
        }
        
        ; 3. Update the CURRENT line with new data.
        GUI_Debug.G_MAIN['Line0_Text'].Value := TEXT_LINE2
        GUI_Debug.G_MAIN['Line0_Name'].Value := TEXT_LINE1
    }


    /**
     * @desc
     * **NEW NAME/LOCATION:** Function called by SetTimer to check for changes 
     * in the global 'ReturnDebug' variable and update the GUI if a change is detected.
     */
    static Update() {

        ; Deconstruct the current state
        Current_Line1 := this.CurrentState[1]
        Current_Line2 := this.CurrentState[2]
        Ping_Triggered := this.CurrentState[3]
        
        ; Deconstruct the old state from the static property
        Old_Line1 := GUI_Debug.HISTORY_STATE_OLD[1]
        Old_Line2 := GUI_Debug.HISTORY_STATE_OLD[2]

        ; Check if a PING was triggered OR if the values are different from the last updated values
        ; Note: We only check Line1/Line2 for changes, Ping_Triggered forces a shift regardless of value change.
        if (Ping_Triggered || Current_Line1 != Old_Line1 || Current_Line2 != Old_Line2) {

            ; --- LOGIC DE D√âCALAGE ET DE MISE √Ä JOUR ---

            ; PING / UPDATE NORMAL: HISTORY2 prend le contenu de HISTORY1
            GUI_Debug.G_MAIN['Line2_Text'].Value := GUI_Debug.G_MAIN['Line1_Text'].Value
            GUI_Debug.G_MAIN['Line2_Name'].Value := GUI_Debug.G_MAIN['Line1_Name'].Value

            ; PING / UPDATE NORMAL: HISTORY1 prend le contenu de CURRENT
            GUI_Debug.G_MAIN['Line1_Text'].Value := GUI_Debug.G_MAIN['Line0_Text'].Value
            GUI_Debug.G_MAIN['Line1_Name'].Value := GUI_Debug.G_MAIN['Line0_Name'].Value

            ; 3. Mise √† jour de la ligne CURRENT avec les nouvelles donn√©es
            GUI_Debug.G_MAIN['Line0_Text'].Value := Current_Line2 ; Function/Result
            GUI_Debug.G_MAIN['Line0_Name'].Value := Current_Line1 ; Hotkey/Trigger

            ; --- MISE √Ä JOUR DE L'HISTORIQUE ET RESET DU PING ---

            ; Mettre √† jour l'historique statique
            GUI_Debug.HISTORY_STATE_OLD := [Current_Line1, Current_Line2, false] ; Ping is always reset here

            ; **IMPORTANT** : R√©initialiser la variable globale ReturnDebug (surtout le flag PING)
            ; pour √©viter un d√©calage continu lors du prochain cycle SetTimer
            GUI_Debug.CurrentState := [Current_Line1, Current_Line2, false]
        }
    }
}

//// SideNote.ahk

#Requires AutoHotkey v2.0
#singleinstance force

; --- IMPORTS ---
#Include "%A_ScriptDir%\SupportFiles\AHK\RichEdit.ahk"
#Include "%A_ScriptDir%\SupportFiles\AHK\RichEditDlgs.ahk"


; Coordonn√©es de la souris bas√©es sur l'√©cran
CoordMode "Mouse", "Screen"
; --------------------------------------------------------------------------------------------------
; CLASSE STATIQUE POUR LE PANNEAU DE NOTES LAT√âRAL
; --------------------------------------------------------------------------------------------------

class GUI_SideNote
{
    ; --- CONFIGURATION STATIQUE (Propri√©t√©s de la classe) ---
    static notesFile := A_ScriptDir "\notes.rtf"
    static panelWidth := 400
    static panelOpacity := 255
    static showDelay := 200     ; ms (avant de glisser)
    static autoSaveInterval := 1000 ; ms (intervalle de sauvegarde)
    static slideSpeed := 50     ; Plus petit est plus rapide
    static margin := 5          ; Marge en pixels pour la d√©tection du bord de l'√©cran

    ; --- VARIABLES D'√âTAT (Propri√©t√©s de la classe) ---
    static isPanelShown := false
    static hoverStartTime := 0
    static mouseIsOverPanel := false

    ; --- CONTR√îLES GUI (Propri√©t√©s de la classe) ---
    static GuiPanel := ""       ; Le GUI principal
    static richEditControl := "" ; Le contr√¥le RichEdit pour les notes
    static btnDummy := ""       ; Bouton factice pour d√©placer le focus

    ; --- DIMENSIONS DE L'√âCRAN (Propri√©t√©s de la classe) ---
    static primaryScreenWidth := 0
    static primaryScreenHeight := 0
    
    ; ----------------------------------------------------------------------------------------------
    ; M√âTHODE D'INITIALISATION
    ; ----------------------------------------------------------------------------------------------

    static Init()
    {
        ; R√©cup√©ration des dimensions de l'√©cran
        this.primaryScreenWidth := SysGet(0)
        this.primaryScreenHeight := SysGet(1)

        ; Cr√©ation du GUI
        this.GuiPanel := Gui("+AlwaysOnTop -Caption +ToolWindow")
        this.GuiPanel.Color := "aaaaaa" 
        this.GuiPanel.Width := this.panelWidth
        this.GuiPanel.Height := this.primaryScreenHeight - 100
        ; Position initiale (cach√© √† droite de l'√©cran)
        this.GuiPanel.X := this.primaryScreenWidth
        ; Centrage Vertical
        this.GuiPanel.Y := (this.primaryScreenHeight - this.GuiPanel.Height) // 2 
        
        ; Cr√©ation du contr√¥le RichEdit
        this.richEditControl := RichEdit(this.GuiPanel, "w" this.panelWidth " h" this.GuiPanel.Height " vNotesEdit")
        this.richEditControl.WordWrap(true)
        this.richEditControl.ShowScrollBar(0, False) ; Cacher les barres de d√©filement si inutiles
        this.richEditControl.ShowScrollBar(1, False)

        ; Configuration des couleurs et du bouton factice
        this.GuiPanel.BackColor := this.GuiPanel.Color
        this.btnDummy := this.GuiPanel.Add("Button", "w1 h1 x-10 y-10", "") 
        this.btnDummy.Visible := false 

        ; Chargement du contenu existant
        this.LoadNotes()
        
        ; Configuration de la police
        this.richEditControl.SetDefaultFont({Size: 16, Color: 0x000000, Name: "Atkinson Hyperlegible Regular"}) 
        
        ; Affichage initial du GUI (cach√©)
        this.GuiPanel.Show("x" this.GuiPanel.X " y" this.GuiPanel.Y)
        
        ; Configuration des √©v√©nements
        this.GuiPanel.OnEvent("Close", (*) => ExitApp())
        this.GuiPanel.OnClose := this.OnGuiClose.Bind(this)
        
        ; D√©marrage des timers
        SetTimer this.AutoSaveNotes.Bind(this), this.autoSaveInterval
        SetTimer this.CheckMouseHover.Bind(this), 100
    }
    
    ; ----------------------------------------------------------------------------------------------
    ; FONCTIONS DE GESTION DES NOTES
    ; ----------------------------------------------------------------------------------------------

    static LoadNotes()
    {
        if FileExist(this.notesFile) {
            content := FileRead(this.notesFile)
            this.richEditControl.SetText(content) 
            ; Positionner le curseur √† la fin du texte
            pos := StrLen(content)
            this.richEditControl.SetSel(pos, pos) 
            
            this.btnDummy.Focus() ; D√©placer le focus vers le bouton invisible
        }
    }

    static AutoSaveNotes() 
    {
        ; R√©cup√©rer le contenu du RichEdit
        contentToSave := this.richEditControl.GetText()
        file := FileOpen(this.notesFile, "w") 
        
        if !file {
            ; En environnement de production, utiliser une m√©thode non bloquante (Log ou Toast Notification)
            ; MsgBox("Erreur lors de l'ouverture du fichier pour l'√©criture.", "Erreur de Sauvegarde")
            return
        }
        file.Write(contentToSave)
        file.Close()
    }

    static OnGuiClose() 
    {
        ; 1. Sauvegarder le contenu (√©tape critique)
        this.AutoSaveNotes()
        
        ; 2. Appel √† la fonction qui g√®re le glissement vers la droite (cacher)
        this.SlidePanel(false)
        
        ; Nous ne mettons PAS d'ExitApp() ici, sinon le script complet se ferme.
    }

    ; ----------------------------------------------------------------------------------------------
    ; GESTION DU HOVER ET DU GLISSEMENT
    ; ----------------------------------------------------------------------------------------------

    static CheckMouseHover() 
    {
        MouseGetPos(&mx, &my)

        x := 0, y := 0, w := 0, h := 0
        this.GuiPanel.GetPos(&x, &y, &w, &h)

        panelLeft := x
        panelRight := x + w
        panelTop := y
        panelBottom := y + h

        ; 1. Souris SUR le panneau GUI
        mouseOverWindow := (mx >= panelLeft && mx <= panelRight && my >= panelTop && my <= panelBottom)
        ; 2. Souris SUR le bord droit de l'√©cran
        mouseOverScreenEdge := (mx >= (this.primaryScreenWidth - this.margin) && mx <= this.primaryScreenWidth)

        mouseOver := mouseOverWindow || mouseOverScreenEdge
        
        ; V√©rifier si le panneau GUI est la fen√™tre active (focus)
        activeID := WinActive("A") 
        GuiPanelID := this.GuiPanel.Hwnd
        isFocused := (activeID = GuiPanelID)

        if mouseOver || isFocused {
            if !this.mouseIsOverPanel {
                ; D√©but du survol
                this.mouseIsOverPanel := true
                this.hoverStartTime := A_TickCount
            } else if (A_TickCount - this.hoverStartTime >= this.showDelay && !this.isPanelShown) {
                ; Le d√©lai est √©coul√©, afficher le panneau
                this.SlidePanel(true)
            }
        } else {
            if (this.mouseIsOverPanel) { 
                ; La souris vient de sortir
                this.mouseIsOverPanel := false
                this.hoverStartTime := 0

                if (this.isPanelShown) { 
                    ; Cacher le panneau si visible
                    this.SlidePanel(false)
                }
            }
        }
    }

    static SlidePanel(show) 
    {
        ; Calculer la position X cible (visible ou cach√©e)
        ; -15 pour laisser une petite bordure visible, si souhait√©
        targetX := show ? (this.primaryScreenWidth - this.panelWidth - 15) : this.primaryScreenWidth

        xPos := 0, yPos := 0, w := 0, h := 0
        this.GuiPanel.GetPos(&xPos, &yPos, &w, &h)
        currentX := xPos

        direction := (targetX < currentX) ? -1 : 1 ; -1 pour glisser √† gauche (show), 1 pour glisser √† droite (hide)

        ; Boucle d'animation
        while ((direction == 1 && currentX < targetX) || (direction == -1 && currentX > targetX)) {
            currentX += direction * this.slideSpeed

            ; S'assurer de ne pas d√©passer la cible
            if ((direction == 1 && currentX > targetX) || (direction == -1 && currentX < targetX))
                currentX := targetX

            this.GuiPanel.Move(currentX, this.GuiPanel.Y)
            Sleep 10 ; D√©lai pour l'animation
        }

        this.isPanelShown := show
    }
}

//// AfterFX_Class.ahk

class KS_AfterFX {
    static CompSettings := "^{k}"
    static Nest := "^+{c}"

    static Timeline := {        
        UnZoom: '{)}',
        Zoom: '{=}',
        ZoomInFrame: '^+{=}',
        ToggleZoom: '^!{√†}',

    }

    static Keyframe := {
        Prev: '^{Left}',
        Next: '^{Right}',
        MorePrev: '^+{Left}',
        MoreNext: '^+{Right}',
        SelNext: '!{Right}',
        SelPrev: '!{Left}'
    }

    static Player := {
        UnZoom: "^{)}",
        Zoom: "^{=}",
        Fit: "^{√†}"
    }
}

//// PremierePro_Hotkeys.ahk
/*************************************************************************************************************
**************************************************************************************************************
                                                    @README
**************************************************************************************************************
*************************************************************************************************************/

/**
¬†* Some windows default hotkey are awfull and useless. Like if you do in this right order :
¬†* {LWin} + {LAlt} + {LShift} + {LCtrl}, it will open "https://m365.cloud.microsoft/?from=OfficeKey"
¬†* because microsoft want to reminds you that your computer is not yours. Lol.
¬†* I tried everything, and you can still have this F*CKING page showing up, so if you want to remove it
¬†* completly, use Regedit (you should have a warning box when you launch my script, if not then : )
¬†*¬†
¬†* Open CMD as admin and write down :
¬†* REG ADD HKCU\Software\Classes\ms-officeapp\Shell\Open\Command /t REG_SZ /d rundll32
¬†*¬†
¬†* Not harmfull at all, will only remove THIS microsoft shortcut DEFINITELY. Be sure before doing so.
¬†*¬†
¬†*/

/*************************************************************************************************************
**************************************************************************************************************
                                                    @MOUSE
**************************************************************************************************************
*************************************************************************************************************/
/**
 * @Simple_Press -> Right Click
 * @Double_Press -> Open the right click windows menu and press "{l}" to navigate on "Label".
 *                 be carefull using it, don't work on subtitles tracks.
 * @Hold         -> Move playhead to mouse
 * @On_release   -> If it was "Hold", Focus the panel under mouse
 */
RButton::{
    ActionsExecuted := HandleKeyGestures(PressedHotkey, Open_Label, Playhead_ToMouse, Panel_UnderMouse)
    GUI_Debug.ReturnDebug "{RButton}", "HandleKeyGestures() -> " ActionsExecuted, true
}

/**
 * @Simple_Press -> Middle Click
 * @Hold         -> Press the "hand" tool, and hold Right Click button for navigation on timeline
 * @On_release   -> If it was "Hold", turn back the selection tool.
 */
MButton::{
    ActionsExecuted := HandleKeyGestures(PressedHotkey, , Hold, Tool_Hand, Reset_LButton)
    GUI_Debug.ReturnDebug "{MButton}", "HandleKeyGestures() -> " ActionsExecuted, true
}

F13::{
    ActionsExecuted := HandleKeyGestures(ZoomOut, , , Panel_UnderMouse)
    GUI_Debug.ReturnDebug "{WheelLeft} := #{Left})", "HandleKeyGestures() -> " ActionsExecuted, true
}

F14::{
    ActionsExecuted := HandleKeyGestures(ZoomIn, , , Panel_UnderMouse)
    GUI_Debug.ReturnDebug "{WheelRight} := #{Right})", "HandleKeyGestures() -> " ActionsExecuted, true
}

!F13::{
    ActionsExecuted := HandleKeyGestures(KeyframeSelPrev, , , Panel_EffectControls, Panel_UnderMouse)
    GUI_Debug.ReturnDebug "{Alt} + {WheelLeft} := #{Left})", "HandleKeyGestures() -> " ActionsExecuted, true
}

!F14::{
    ActionsExecuted := HandleKeyGestures(KeyframeSelNext, , , Panel_EffectControls, Panel_UnderMouse)
    GUI_Debug.ReturnDebug "{Alt} + {WheelRight} := #{Left})", "HandleKeyGestures() -> " ActionsExecuted, true
}


^b::MsgBox(Project.Activate())


/*************************************************************************************************************
**************************************************************************************************************
                                                    @KEYBOARD
**************************************************************************************************************
*************************************************************************************************************/

^v::{
    Paste()
    GUI_Debug.ReturnDebug "{CTRL} + {v}", "Paste()", true
}

^Backspace::{
    TrueCtrlBackspace()
    GUI_Debug.ReturnDebug "{CTRL} + {Backspace}", "TrueCtrlBackspace()", true
}

^*::{
    TrueFullscreen("vkDCsc02B")
    GUI_Debug.ReturnDebug "{CTRL} + {VKDC}", "TrueFullscreen() -> 'vkDCsc02B', needed only for non-english keyboards", true
}

F4::{
    HandleKeyGestures(Focus_SearchBox, , , Panel_Effect)
    GUI_Debug.ReturnDebug "{F4}", "HandleKeyGestures() -> Focus 'Effects' then 'Search Box'", true
}

^w::{
    CloseWin()
    GUI_Debug.ReturnDebug "{CTRL} + {w}", "CloseWin()", true
}

z::{
    HandleKeyGestures(, , Hold, PressedHotkey, Tool_Normal, true)
    GUI_Debug.ReturnDebug "{z}", "HandleKeyGestures() -> Tool 'Cutter' when hold, default tool on release", true
}
r::{
    HandleKeyGestures(, , Hold, PressedHotkey, Tool_Normal, true)
    GUI_Debug.ReturnDebug "{r}", "HandleKeyGestures() -> Tool 'Select Forward' when hold, default tool on release", true
}
f::{
    HandleKeyGestures(, , Hold, PressedHotkey, Tool_Normal, true)
    GUI_Debug.ReturnDebug "{f}", "HandleKeyGestures() -> Tool 'Slip' when hold, default tool on release", true
}
g::{
    HandleKeyGestures(, , Hold, PressedHotkey, Tool_Normal, true)
    GUI_Debug.ReturnDebug "{g}", "HandleKeyGestures() -> Tool 'Slide' when hold, default tool on release", true
}
b::{
    HandleKeyGestures(, , Hold, PressedHotkey, Tool_Normal, true)
    GUI_Debug.ReturnDebug "{b}", "HandleKeyGestures() -> Tool 'Speed' when hold, default tool on release", true
}

!s::{
    Motion.HotValue("PrUI_", "DarkestHC_", "Scale", ".png")
    GUI_Debug.ReturnDebug "{ALT} + {s}", 'Motion.HotValue() -> Imagesearch for "Scale" property', true
}
!r::{
    Motion.HotValue("PrUI_", "DarkestHC_", "Rotation", ".png")
    GUI_Debug.ReturnDebug "{ALT} + {r}", 'Motion.HotValue() -> Imagesearch for "Rotation" property', true
}

^+r::{
    HandleKeyGestures(Show_Rulers, , , Panel_Player, Panel_Timeline)
    GUI_Debug.ReturnDebug "{CTRL} + {SHIFT} + {R}", 'HandleKeyGestures() -> Show Rulers + Margins', true
}

¬≤::{
    HandleKeyGestures(Player_Fit, , , Panel_EffectControls, Panel_UnderMouse, )
    GUI_Debug.ReturnDebug "{¬≤}", 'HandleKeyGestures() -> Restore Monitor to fit', true
}
!¬≤::{
    ClipClear()
    GUI_Debug.ReturnDebug "{ALT} + {?}", "ClipClear()", true
}



;+PgUp::ClipGain(+2.5)
;+PgDn::ClipGain(-2.5)

NumpadLeft::{
    Mouse.Move.Pixel(-10)
    GUI_Debug.ReturnDebug "{NumpadLeft}", "Mouse.Move() -> 10px left", true
}

NumpadRight::{
    Mouse.Move.Pixel(+10)
    GUI_Debug.ReturnDebug "{NumpadRight}", "Mouse.Move() -> 10px right", true
}

NumpadUp::{
    Mouse.Move.Pixel( , -10)
    GUI_Debug.ReturnDebug "{NumpadUp}", "Mouse.Move() -> 10px down", true
}

NumpadDown::{
    Mouse.Move.Pixel( , +10)
    GUI_Debug.ReturnDebug "{NumpadDown}", "Mouse.Move() -> 10px up", true
}

^space::{
    SendInput KS_Premiere.SelectPanel.Effects
    Sleep(200)
    SendInput KS_Premiere.SearchBox
    GUI_Debug.ReturnDebug "{Ctrl} + {Space}", "Focus 'Effects' then 'Search Box'", true
}

/*************************************************************************************************************
**************************************************************************************************************
                                                    @KEYPAD
**************************************************************************************************************
*************************************************************************************************************/

/*
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
*/

;@_PadKey1
Browser_Home::{
    Effects.Search("#MO")
    GUI_Debug.ReturnDebug "{PadKey1} => {Browser_Home}", "Effects.Search() => '#MO'", true
}

;@_PadKey2
Browser_Favorites::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\.Watchfolder", false)
    GUI_Debug.ReturnDebug "{PadKey2} => {Browser_Favorites}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\.Watchfolder'", true
}

;@_PadKey3
Browser_Search::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\.Renders", false)
    GUI_Debug.ReturnDebug "{PadKey3} => {Browser_Search}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\.Renders'", true
}

;@_PadKey4
Browser_Refresh::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\Sessions", false)
    GUI_Debug.ReturnDebug "{PadKey4} => {Browser_Refresh}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\Sessions'", true
}


/*
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
*/

;@_PadKey5
Launch_App1::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Files", false)
    GUI_Debug.ReturnDebug "{PadKey5} => {Launch_App1}", "Application.Window() => 'Z:\Files'", true
}

;@_PadKey6
Launch_App2::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Videos", false)
    GUI_Debug.ReturnDebug "{PadKey6} => {Launch_App2}", "Application.Window() => 'Z:\Videos'", true
}

;@_PadKey7
F15::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Pictures", false)
    GUI_Debug.ReturnDebug "{PadKey7} => {F15}", "Application.Window() => 'Z:\Pictures'", true
}

;@_PadKey8
F16::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Sounds", false)
    GUI_Debug.ReturnDebug "{PadKey8} => {F16}", "Application.Window() => 'Z:\Sounds'", true
}

/*
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
*/

;@_PadKey9
F17::{
    GUI_Debug.ReturnDebug "{PadKey9} => {F17}", "NONE", true
}

;@_PadKey10
F18::{
    GUI_Debug.ReturnDebug "{PadKey10} => {F18}", "NONE", true
}

;@_PadKey11
F19::{
    GUI_Debug.ReturnDebug "{PadKey11} => {F19}", "NONE", true
}

;@_PadKey12
F20::{
    GUI_Debug.ReturnDebug "{PadKey12} => {F20}", "NONE", true
}


/*
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
*/

;@_PadKey13
F21::{
    GUI_Debug.ReturnDebug "{PadKey13} => {F21}","Keyframe.Perform() => " Keyframe.Perform("Select", "Prev") , true
}

;@_PadKey14
F22::{
    GUI_Debug.ReturnDebug "{PadKey13} => {F21}","Keyframe.Perform() => " Keyframe.Perform("Select", "Next") , true
}

;@_PadKey15
F23::{
    GUI_Debug.ReturnDebug "{PadKey13} => {F21}","Keyframe.Perform() => " Keyframe.Perform("Move", "Video", "-1") , true
}

;@_PadKey16
F24::{
    GUI_Debug.ReturnDebug "{PadKey13} => {F21}","Keyframe.Perform() => " Keyframe.Perform("Move", "Video", "+1") , true
}

            /*************************************************************************************
                                                @KEYPAD_SMALLWHEEL1
            *************************************************************************************/

Media_Prev::{
    SendInput(KS_Premiere.Clip.VolumeDown)
    GUI_Debug.ReturnDebug "MACROPAD / {Media_Prev}", "SendInput(KS_Premiere.Clip.VolumeDown)", true
}

Media_Play_Pause::{
    Send("{Media_Play_Pause}")
    GUI_Debug.ReturnDebug "{PadSmallWheel1 Left} => {Media_Play_Pause}", "SendInput() => {Media_Play_Pause}", true
}

Media_Next::{
    SendInput(KS_Premiere.Clip.VolumeUp)
    GUI_Debug.ReturnDebug "MACROPAD / {Media_Next}", "SendInput(KS_Premiere.Clip.VolumeUp)", true
}

            /*************************************************************************************
                                                @KEYPAD_SMALLWHEEL2
            *************************************************************************************/
Volume_Down::{
    SendInput(KS_Premiere.Keyframe.Prev)
    GUI_Debug.ReturnDebug "MACROPAD / {Volume_Down}", "SendInput(KS_Premiere.Keyframe.Prev)", true
}
^Volume_Down::{
    SendInput(KS_Premiere.Keyframe.MorePrev)
    GUI_Debug.ReturnDebug "MACROPAD / {CTRL} + {Volume_Down}", "SendInput(KS_Premiere.Keyframe.MorePrev)", true
}
Volume_Up::{
    SendInput(KS_Premiere.Keyframe.Next)
    GUI_Debug.ReturnDebug "MACROPAD / {Volume_Up}", "SendInput(KS_Premiere.Keyframe.Next)", true
}
^Volume_Up::{
    SendInput(KS_Premiere.Keyframe.MoreNext)
    GUI_Debug.ReturnDebug "MACROPAD / {CTRL} + {Volume_Up}", "SendInput(KS_Premiere.Keyframe.MoreNext)", true
}
Volume_Mute::{
    SendInput("{s}")
    GUI_Debug.ReturnDebug "MACROPAD / {Volume_Mute}", "Split Clip", true
}

            /*************************************************************************************
                                                    @BIGWHEEL
            *************************************************************************************/

Browser_Back::{
    HandleKeyGestures(KeyframeSelPrev, , , Panel_EffectControls, Panel_UnderMouse)
    GUI_Debug.ReturnDebug "MACROPAD / {Browser_Back}", "HandleKeyGestures(KeyframeSelPrev, , , Panel_EffectControls, Panel_UnderMouse)", true
}

Browser_Forward::{
    HandleKeyGestures(KeyframeSelNext, , , Panel_EffectControls, Panel_UnderMouse)
    GUI_Debug.ReturnDebug "MACROPAD / {Browser_Forward}", "HandleKeyGestures(KeyframeSelNext, , , Panel_EffectControls, Panel_UnderMouse)", true
}






/***********************************************************************************
                                                  @FUNCTIONS
***********************************************************************************/

    Hold := [(Actions) => Sleep(10)]
    PressedHotkey := [(Actions) => SendInput("{" ThisHotkey := CleanHotkey() "}")]

    Panel_UnderMouse := [(Actions) => (Mouse.FocusActive())]
    Panel_Timeline := [(Actions) => SendInput(KS_Premiere.SelectPanel.Timeline)]
    Panel_EffectControls := [(Actions) => SendInput(KS_Premiere.SelectPanel.EffectControls)]
    Panel_Effect := [(Actions) => SendInput(KS_Premiere.SelectPanel.Effects)]
    Panel_Player := [(Actions) => SendInput(KS_Premiere.SelectPanel.Player)]

    Playhead_ToMouse := [(Actions) => SendInput(KS_Premiere.PlayheadToMouse)]

    ZoomComp := [(Actions) => SendInput(KS_Premiere.Timeline.ZoomComp)]
    ZoomOut := [(Actions) => SendInput(KS_Premiere.Timeline.ZoomOut)]
    ZoomIn := [(Actions) => SendInput(KS_Premiere.Timeline.ZoomIn)]
    ZoomFrame := [(Actions) => SendInput(KS_Premiere.Timeline.ZoomComp)]

    Player_Fit := [(Actions) => (
              SendInput(KS_Premiere.Player.Fit)
              Sleep(12)
              SendInput(KS_Premiere.Player.Fit100)
              Sleep(12)
              SendInput(KS_Premiere.Player.Fit)
          )
    ]
    Player_ZoomIn := [(Actions) => SendInput(KS_Premiere.Player.ZoomIn)]
    Player_ZoomOut := [(Actions) => SendInput(KS_Premiere.Player.ZoomOut)]

    KeyframeSelPrev := [(Actions) => SendInput(KS_Premiere.Keyframe.SelPrev)]
    KeyframeSelNext := [(Actions) => SendInput(KS_Premiere.Keyframe.SelNext)]
    KeyframePrev := [(Actions) => SendInput(KS_Premiere.Keyframe.Prev)]
    KeyframeNext := [(Actions) => SendInput(KS_Premiere.Keyframe.Next)]
    KeyframeMorePrev := [(Actions) => SendInput(KS_Premiere.Keyframe.MorePrev)]
    KeyframeMoreNext := [(Actions) => SendInput(KS_Premiere.Keyframe.MoreNext)]

    Show_Rulers :=
          (Actions) => (
              SendInput(KS_Premiere.Player.ShowMargins)
              Sleep(15)
              SendInput(KS_Premiere.Player.ShowRulers)
              Sleep(15)
              SendInput(KS_Premiere.Player.ShowGuides)
          )

    Open_Label := [ 
          (Actions) => (
              BlockInput("On") 
              SendInput("{RButton}")
              Sleep(65)
              SendInput("{l}")
              BlockInput("Off")
          )
    ]

    Focus_SearchBox := [ 
          (Actions) => (
              Sleep(150)
              SendInput(KS_Premiere.SearchBox)
          )
    ]

    Tool_Hand := [
          (Actions) => (
              SendInput(KS_Premiere.Tool.Hand)
              SendInput("{LButton down}")
          )
    ] 

    Tool_Razor := [(Actions) => (SendInput(KS_Premiere.Tool.Razor))]
    Tool_Normal := [(Actions) => (SendInput(KS_Premiere.Tool.Normal))]
    Tool_Slip := [(Actions) => (SendInput(KS_Premiere.Tool.Slip))]
    Tool_Slide := [(Actions) => (SendInput(KS_Premiere.Tool.Slide))]

    Reset_LButton := [
          (Actions) => (
              SendInput("{LButton up}")
              SendInput(KS_Premiere.Tool.Normal)
          )
    ]

    MarkersPrevious := [(Actions) => (SendInput(KS_Premiere.Markers.Previous))]
    MarkersNext := [(Actions) => (SendInput(KS_Premiere.Markers.Next))]
    MarkersYellow := [(Actions) => (SendInput(KS_Premiere.Markers.Add.Yellow))]





;If Toggle.Capslock() {
;    
;    ^NumpadAdd::{
;        ValueEdit("+5")
;        GUI_Debug.ReturnDebug "{CTRL} + {NumpadAdd}", "ValueEdit('+5')", true
;    }
;    ^NumpadSub::{
;        ValueEdit("-5")
;        GUI_Debug.ReturnDebug "{CTRL} + {NumpadSub}", "ValueEdit('-5')", true
;    }
;    NumpadAdd::{
;        ValueEdit("+10")
;        GUI_Debug.ReturnDebug "{NumpadAdd}", "ValueEdit('+10')", true
;    }
;    NumpadSub::{
;        ValueEdit("-10")
;        GUI_Debug.ReturnDebug "{NumpadSub}", "ValueEdit('-10')", true
;    }
;}


;+q::HandleKeyGestures(KeyframeMorePrev, , KeyframeMorePrev, , )
;+d::HandleKeyGestures(KeyframeMoreNext, , KeyframeMoreNext, , )


//// PremierePro_Class.ahk

; Custom Class made for hotkeys in Premiere Pro.
; All hotkeys that you use in Premiere Pro, must be assigned there.

class KS_Premiere {

    static Excalibur := "^{Space}"
    
    static SelectPanel := {
        EffectControls: "{F2}",
        Properties: "{F3}",
        Bin: "{F1}",
        Effects: "{F4}",
        Player: '{F7}',
        Timeline: "{F8}",
        NextPanel: "^+{$}",
        PrevPanel: "^+{^}"
    }

    static Keyframe := {
        Prev: "{Numpad4}", 
        Next: "{Numpad6}",
            ;Need to be something else than an arrow key, dunno why, but when you are in "transform" mode
            ;and if you presse "left", it will move the layer 1 pixel left. It will not go back one frame.
            MorePrev: "+{NumpadLeft}",
            MoreNext:"+{NumpadRight}",

        Perform: {
            Video: "{Numpad8}",
            Audio: "{Numpad5}",
        },
            
        SelPrev: "{Numpad7}",
        SelNext: "{Numpad9}",

        Move:{
            Video: {
                Back: { 1:"!{Numpad7}", 10:"!+{Numpad7}" },
                Forw: { 1:"!{Numpad9}", 10:"!+{Numpad9}" },
            },
            Audio: {
                Back: { 1:"!{Numpad1}", 10:"!+{Numpad1}" },
                Forw: { 1:"!{Numpad3}", 10:"!+{Numpad3}" },
            },
        },

        MoveAudioForward: "^+{Right}",
        MoveAudioBackward: "^+{Left}",

    }

    static Clip := {
        Prev: "{Down}",
        Next:"{Up}",
        VolumeDown: "{PgDn}",
        VolumeUP: "{PgUp}",
        Rename: '{Backspace}',
    }

    static Bin := {
        Rename: "{Backspace}"
    }

    static Player := {
        Fit: "{¬≤}",
        Fit100: "^+!{¬≤}",
        Transform: "^{t}",
        ShowGuides: "+{r}",
        ShowRulers: "^{r}",
        ShowMargins: "^+{r}",
        ShowOverlay: "^+{o}"
    }

    static Tool := {
        Razor: "{z}",
        Normal: "{v}",
        Hand: "{h}",
        Text: "{t}",
        Slip: "{f}",
        Slide: "{g}"
    }

    static Timeline := { 
        ZoomComp: "^+{)}",       
        ZoomOut: '{)}',
        ZoomIn: "{=}",
        ZoomFrame: "^+{=}",  
        Cut: "{s}",       
        Selection_Follow_Playhead: '{*}',
    }

    class Markers {
        static Add := {
            Yellow: '^{,}',
            Red: "{,}",
        }
        static Next := "{:}"
        static Previous := "{;}"
    }

    class AltMenu {
        class Edit {
            static Prefix := "!{e}"
            static Label := this.Prefix "{l}"
        }
    }

    class ShowProperties {
        static All := "{o}"
        static Edited := "{u}"
    }

    static CompSettings := "^{k}"
    static MaximizePanel := "^+{*}"

    static Play := "{space}"

    static Save := "^{s}"
    static SaveAs := "^+{s}"
    static SaveAsCopy := "^!{s}"

    static AfterComposition := "^!+{m}"

    static Unselect := "^+{D}"
        
    static SearchBox := "^{f}"
    static DeselectAll := "^+{D}"

    static SendToAE := "^!+{m}"
    static GlobalFXMute := "{NumpadAdd}"
    static EffectSettings_SavePreset:= "^!+{P}"
    static Nesting := "{Enter}"
    static RippleDelete := "+{Delete}"
    static AddEdit := "{S}"
    static Enable := "{e}"
    static PlayheadToMouse := "{<}"
    static AudioGain := "{y}"
    
    static Volume := {
        Up: "^{PgUp}",
        Down: "^{PgDn}"
    }

    static Attributes := {
        Add: "^{!}",
        Sub: "!{!}"
        ; "ALT" + "!"
    }

    static Plugins := {
        Excal: "^{Space}"
    }

}


//// ApplyPreset.ahk

#Requires AutoHotkey v2.0

/**
 * @function ApplyPreset
 * Guides the user to visually drag an effect preset from the Effects panel
 * onto the timeline in Adobe Premiere Pro. It handles panel activation,
 * mouse confinement, and input blocking during the drag operation.
 * NOTE: This function relies on external definitions like KS_Premiere.SelectPanel.Effect, 
 * KS_Premiere.SearchBox, TimedTooltip, and ClassNN_ToCoords.
 * @param {boolean} [ClosePanel=false] If true, sends Ctrl+W after the drag operation to close the Effects panel.
 * @returns {void}
 */
ApplyPreset(ClosePanel := false) {
    
    ; Ensure coordinate modes are set to 'Screen' for reliable positioning across monitors.
    CoordMode "Pixel", "Screen"
    CoordMode "ToolTip", "Screen"
    CoordMode "Mouse", "Screen"
    
    ; Ensure the left mouse button is released before starting the operation.
    SendInput "{LButton Up}"

    ; Store the mouse's starting position to restore it later.
    MouseGetPos &mStart_X, &mStart_Y
    
    ; Send the hotkey/command to select/focus the Effects panel (must be defined externally).
    SendInput KS_Premiere.SelectPanel.Effect
    Sleep 250 ; Give the application time to focus the panel.

    ; Identify the active window handle (expected to be Premiere Pro).
    hwnd := WinExist("A")
    try {
        ; Get the ClassNN of the currently focused control (which should be the Effects panel content).
        effectClassNN := ControlGetClassNN(ControlGetFocus(hwnd))
    }
    catch {
        ; If the focus cannot be retrieved (e.g., panel is missing), show an error tooltip and exit.
        Tooltip("Can't find effect panel.`n" . "Panel was probably closed, try again." . "", 4000)
        Exit
    }

    ; Get the position and dimensions of the focused control (Effects panel content).
    ControlGetPos &x, &y, &w, &h, effectClassNN, hwnd
    
    ; Send the hotkey/command to focus the Search Box within the panel (must be defined externally).
    SendInput KS_Premiere.SearchBox

    Sleep 50
    ; Get the ClassNN of the search box (used to identify the panel, though the effectClassNN is used for dimensions).
    searchClassNN := ControlGetClassNN(ControlGetFocus(hwnd))
    
    ; Convert the control's coordinates (relative to the window) to screen coordinates.
    ; NOTE: This helper function must be defined elsewhere.
    coords := ClassNN_ToCoords(hwnd, x, y, w, h)

    ; Move the mouse cursor to the center of the Effects panel's content area.
    MouseMove (coords.x_screen + w // 2), (coords.y_screen + h // 2)
    
    ; Confine the mouse cursor to the boundaries of the Effects panel during the selection phase.
    ClipCursor({x1: coords.x_screen, y1: coords.y_screen, x2: coords.x_screen + w, y2: coords.y_screen + h})

    ; --- WAIT FOR USER INTERACTION (LButton Click or Esc) ---
    Loop {
        ; Break the loop if the Left Mouse Button is pressed (user has clicked a preset).
        if GetKeyState("LButton")
            break
        ; Exit the function cleanly if the Escape key is pressed (user cancels).
        if GetKeyState("Esc") {
            ClipCursor() ; Release the cursor lock.
            MouseMove mStart_X, mStart_Y ; Restore original mouse position.
            Exit
        }
        Sleep(15)
    }

    ; Release the cursor confinement once the user has started the drag.
    ClipCursor()

    ; Block user input to ensure the subsequent drag/drop movement is precise and uninterrupted.
    BlockInput "On" 
    ; Specifically allow mouse movement commands from AHK, but block user mouse movements.
    BlockInput "MouseMove" 

    ; Simulate holding the left mouse button down (beginning the drag).
    SendInput "{LButton Down}"

    ; Simulate a short movement to ensure the drag operation is properly registered by the OS/Application.
    loop 2 {
        ; Move the mouse 30 pixels right (relative to the current position).
        MouseMove 30, 0, , "R"
        Sleep 33
    }

    ; Optional: Close the panel after the drag/drop if requested.
    if ClosePanel {
        ; Sends Ctrl+W to close the active panel in Premiere Pro.
        SendInput "^{w}"
    }
 
    ; Move the mouse back to its original position.
    MouseMove mStart_X, mStart_Y

    ; Release input blocks in reverse order.
    BlockInput "MouseMoveOff"
    BlockInput "Off"
    exit
}

//// ClipClear.ahk

/**
 * @function ClipClear
 * Clears the attributes of the selected clip(s) assuming a predefined sequence of shortcuts.
 * NOTE: This function relies on external definitions: Panel.Focus and KS_Premiere.Attributes.Sub.
 * @returns {void}
 */
ClipClear() {
    ; Ensure the Timeline panel is focused before sending clip-related commands.
    ; NOTE: Panel.Focus is expected to be an external function/method.
    Panel.Focus("Timeline")
    sleep 33 ; Short delay to ensure focus change is complete.
    
    ; Send the hotkey/command sequence to open the 'Remove Attributes' or equivalent dialog.
    ; KS_Premiere.Attributes.Sub is expected to contain the required shortcut (e.g., Alt+Shift+/)
    Send(KS_Premiere.Attributes.Sub)
    
    ; Send {Enter} to confirm the default action in the dialog (typically "OK" or "Apply"), 
    ; effectively clearing the default set of attributes.
    Send("{Enter}")
    return
}

//// ClipGain.ahk

/**
 * @function ClipGain
 * Sets the audio gain value for the currently selected clip(s) in Adobe Premiere Pro.
 * It sends the shortcut to open the Audio Gain dialog, inputs the desired value, and confirms.
 * NOTE: This function relies on an external definition: KS_Premiere.AudioGain.
 * @param {string|number} value The desired audio gain value (e.g., '3' for +3dB, '-6' for -6dB).
 * @returns {void}
 * @platform Adobe Premiere Pro
 */
ClipGain(value) {
    ; Send the hotkey/command to open the 'Audio Gain' dialog box in Premiere Pro.
    ; KS_Premiere.AudioGain is expected to be defined elsewhere (e.g., 'g').
    SendInput KS_Premiere.AudioGain
    sleep 1 ; Minimal delay after opening the dialog.
    
    ; Input the numerical value directly into the focused field (expected to be the gain adjustment).
    Send value
    sleep 1 ; Minimal delay after inputting the value.
    
    ; Send {Enter} to confirm the operation, applying the gain change to the selected clip(s).
    SendInput "{Enter}"
    return
}

//// closeWin.ahk

#Requires AutoHotkey v2.0

CloseWin() {
    ClassNN := WinGetClass("A")
    if ClassNN = "Premiere Pro"
        Exit
    Else
        WinClose("A")
}

//// Effects.ahk

#Requires AutoHotkey v2.0

class Effects {
    static Search(Input) {
        Panel.Focus("Effects")
        Sleep(150)
        SendInput KS_Premiere.SearchBox
        Sleep(150)
        SendText Input
    }
}

//// Keyframe.ahk

/**
 * @fileoverview AutoHotkey v2.0 Class for managing Keyframe operations in Premiere Pro.
 * * This class provides methods to select and perform actions related to keyframes
 * within the Adobe Premiere Pro application, specifically targeting the
 * "EffectControls" panel.
 */
class Keyframe {

    static _switch(action, choice, subchoice := '') {
        Switch action {
            Case 'Add': Switch choice
                {
                    Case 'Video': return SelChoice := KS_Premiere.Keyframe.Perform.Video.Add
                    Case 'Audio': return SelChoice := KS_Premiere.Keyframe.Perform.Audio.Add
                }

            Case 'Remove': Switch choice
                {
                    Case 'Video': return SelChoice := KS_Premiere.Keyframe.Perform.Video.Del
                    Case 'Audio': return SelChoice := KS_Premiere.Keyframe.Perform.Audio.Del
                }

            Case 'Select': Switch choice
                {
                    Case 'Next': return SelChoice := KS_Premiere.Keyframe.SelNext
                    Case 'Prev': return SelChoice := KS_Premiere.Keyframe.SelPrev
                }

            Case 'Move': Switch choice
                {
                    Case 'Video': Switch subchoice
                        {
                            Case '+1f': return SelChoice := KS_Premiere.Keyframe.Move.Video.Forw.1
                            Case '+10f': return SelChoice := KS_Premiere.Keyframe.Move.Video.Forw.10
                            Case '-1f': return SelChoice := KS_Premiere.Keyframe.Move.Video.Back.1
                            Case '-10f': return SelChoice := KS_Premiere.Keyframe.Move.Video.Back.10
                        }

                    Case 'Audio': Switch subchoice
                        {
                            Case '+1f': return SelChoice := KS_Premiere.Keyframe.Move.Audio.Forw.1
                            Case '+10f': return SelChoice := KS_Premiere.Keyframe.Move.Audio.Forw.10
                            Case '-1f': return SelChoice := KS_Premiere.Keyframe.Move.Audio.Back.1
                            Case '-10f': return SelChoice := KS_Premiere.Keyframe.Move.Audio.Back.10
                        }
                }
            Case 'Default':
                return msgbox("Error: 2 Params needed")
        }
    }

    /**
     * @static
     * @method Keyframe - Executes the chosen keyframe action in Premiere Pro.
     * * 1. **Focuses Panel:** Ensures the "EffectControls" panel in Premiere Pro has focus 
     * using a hypothetical `Panel.Focus()` function.
     * 2. **Selects Hotkey:** Calls the private `_switch` method to retrieve the correct hotkey sequence.
     * 3. **Sends Input:** Sends the selected hotkey sequence using `SendInput`.
     * * @param {string} choice - The action string (e.g., 'Next', 'Prev', 'Add', 'Del').
     */
    static Perform(action, choice, subchoice := '') {
        ; Sets focus to the "EffectControls" panel in Premiere Pro.
        Panel.Focus("EffectControls")
        ; Gets the corresponding AHK key sequence for the requested action.
        sleep 150
        SelChoice := this._switch(action, choice, subchoice := '')
        return SelChoice
    }
}

//// Motion.ahk

#Requires AutoHotkey v2.0

/**
 * @class Motion
 * Provides methods for controlling and manipulating the 'Motion' effect properties
 * within the Effect Controls panel in Adobe Premiere Pro, primarily using image and pixel searching.
 * NOTE: Relies heavily on external functions/classes like Panel.ClassNN, FileNameConstructor, 
 * FindImage, fpath.ImageSearch, KS_Premiere, and WaitForUserConfirm.
 */
class Motion{
    /**
     * @static
     * Initializes the Motion effect for manipulation by finding its location, checking its state (Open/Closed),
     * and toggling it if needed. It uses image search within the Effect Controls panel.
     * @param {string} prefix - Part of the image filename constructor (e.g., application name).
     * @param {string} theme - Part of the image filename constructor (e.g., 'Dark' theme).
     * @param {string} name - The specific name to search for (e.g., 'Motion').
     * @param {string} format - The image file extension (e.g., 'png').
     * @param {string} [picturePath=fpath.ImageSearch] - The directory where search images are located.
     * @param {string} [NewState="Open"] - The desired state for the Motion effect ("Open" or "Close").
     * @param {number} [attempts=3] - Number of times to retry finding the image/effect.
     * @returns {Object|void} An object containing the Effect Controls panel dimensions (x, y, w, h) on success, or void on failure.
     */
    static Initialize(prefix, theme, name, format, picturePath := A_Path.ImageSearch, NewState := "Open", attempts := 3) {
        ; Set coordinate modes to 'Window' for all functions operating within the Premiere window.
        CoordMode "Mouse", "Window"
        CoordMode "ToolTip", "Window"
        CoordMode "Pixel", "Window"
        DllCall("SetProcessDPIAware") ; Ensure DPI scaling compatibility.
        
        imageName := FileNameConstructor(prefix, theme, name, format) ; Construct the name of the image file to search for.

        Sleep(33)
        ClassPanel := Panel.ClassNN("EffectControls") ; Get coordinates and info for the Effect Controls panel.

        Restart:
        sleep 66
        ; Search for the 'Motion' text/icon image within the Effect Controls panel area.
        MotionPos := FindImage(imageName, ClassPanel.x, ClassPanel.y, ClassPanel.w, ClassPanel.h, 150, picturePath)
        
        if !MotionPos {
            attempts--
            sleep 5
            ; Toggle "Selection Follows Playhead" to try and refresh the panel content/selection.
            SendInput KS_Premiere.Timeline.Selection_Follow_Playhead
            sleep 5
            SendInput KS_Premiere.Timeline.Selection_Follow_Playhead
            if attempts = 0 {
                MsgBox("Failed : Make sure you got a Target Track active `n with a layer under playhead", Err)
                Exit
            }
            else
                goto Restart ; Retry image search.
        } else {
            ; Calculate the position of the disclosure triangle (arrow) relative to the found image.
            ArrowPos := {
                X : MotionPos.X-27,
                Y : MotionPos.Y+6
            }
            ;MouseMove ArrowPos.X, ArrowPos.Y, 0
            
            ; Check the pixel color at the arrow position to determine if the effect is open or closed.
            PixelCheck := PixelGetColor(ArrowPos.X, ArrowPos.Y)
            sleep 5
            
            ; Pixel color checks based on Premiere's "Darkest" theme (standard UI colors).
            if (PixelCheck = "0x2E2E2E") {
                ; 0x2E2E2E is the closed/dark state color.
                sleep 5
                ;tooltip "Motion // Twirl : Closed", +200
                state := "Motion // Twirl : Closed"
                }
            if (PixelCheck = "0xC1C1C1") {
                ; 0xC1C1C1 is the opened/light state color.
                sleep 5
                ;tooltip "Motion // Twirl : Opened", +200
                state := "Motion // Twirl : Opened"
                }

            try {
                ; Toggle the state if the current state does not match the desired NewState.
                if NewState = "Close" AND state = "Motion // Twirl : Opened" {
                    BlockInput("MouseMove")
                    Sleep(33)
                    Click "Left", ArrowPos.X, ArrowPos.Y
                    
                }
                else if NewState = "Open" AND state = "Motion // Twirl : Closed" {
                    BlockInput("MouseMove")
                    Sleep(33)
                    Click "Left", ArrowPos.X, ArrowPos.Y
                }
                
                BlockInput("MouseMoveOff") ; Release mouse block after the click, if it occurred.
                
                ; Return the panel coordinates for subsequent operations (e.g., HotBar).
                return {
                    x: ClassPanel.x,
                    y: ClassPanel.y,
                    w: ClassPanel.w,
                    h: ClassPanel.h,
                }
            } catch {
                BlockInput("MouseMoveOff")
                tooltip "Failed : PixelGetColor Error"
                Exit
            }
        }    
    }

    /**
     * @static
     * Searches for a specific text/icon image within the Motion effect section of the Effect Controls panel.
     * This is used to locate a specific property bar (e.g., 'Position', 'Scale').
     * @param {string} prefix - Part of the image filename constructor.
     * @param {string} theme - Part of the image filename constructor.
     * @param {string} name - The specific name of the property bar to search for.
     * @param {string} format - The image file extension.
     * @returns {Object|void} An object containing the coordinates (x, y) and expected dimensions (w: 250, h: 18) of the property bar.
     */
    static HotBar(prefix, theme, name, format) { ; searches for text inside of the Motion effect. requires an actual image.
        CoordMode "Pixel", "Window"
        CoordMode "ToolTip", "Window"
        CoordMode "Mouse", "Window"
        imageName := FileNameConstructor(prefix, theme, name, format)
        attempts := 3

        Restart:
        ; First, ensure the 'Motion' effect is initialized (and opened by default).
        MotionPanel := this.Initialize(prefix, theme, "Motion", format)
        sleep 66

        ; Search for the specific property bar image within the Motion panel's bounds.
        HotbarPos := FindImage(imageName, MotionPanel.x, MotionPanel.y, MotionPanel.w, MotionPanel.h, 150)
        ;sleep(1500)
        if !FindImage{
            attempts--
            if attempts = 0 {
                Exit MsgBox("Failed : FindImage Not Found", Err)
            }
            else
                goto Restart
        } else {
            ;tooltip "FindImage Found"
            ; Move the mouse cursor to the found position.
            MouseMove HotbarPos.X, HotbarPos.Y, 0
            ; Return the position and expected size of the property bar for further actions.
            return { x: HotbarPos.X, y: HotbarPos.Y, w: 250, h: 18}
        }
    }

    /**
     * @static
     * Finds and initiates interaction (click-and-drag) on the numerical value within a Motion property bar
     * (e.g., the 'X' or 'Y' Position value). It uses PixelSearch to find the blue highlight color.
     * @param {string} prefix - Part of the image filename constructor.
     * @param {string} theme - Part of the image filename constructor.
     * @param {string} name - The name of the property bar (e.g., 'Position') to use in HotBar search.
     * @param {string} format - The image file extension.
     * @returns {void}
     */
    static HotValue(prefix, theme, name, format) { ; searches for value inside of the Motion effect. requires an actual image, inside Pr.Focus.HotBar
        CoordMode "Pixel", "Window"
        CoordMode "ToolTip", "Window"
        CoordMode "Mouse", "Window"
        attempts := 3

        MouseGetPos &xStart, &yStart ; Save starting mouse position.
        
        ; Send the hotkey to activate the Transform overlay in the Program Monitor (if defined).
        SendInput KS_Premiere.Player.Transform
        BlockInput "MouseMove" ; Block user mouse movement during search and setup.
        
        ; Find the location of the target property bar (e.g., Position).
        FoobarPos := this.HotBar(prefix, theme, name, format)
        Sleep(5)

        Restart:
        ; Search for the blue color (0x5eaaf7) used to highlight active numerical values in Premiere's UI.
        ; The search area is limited to the property bar found by HotBar.
        FindColor := PixelSearch(&Px, &Py, FoobarPos.x, FoobarPos.y, FoobarPos.x + FoobarPos.w, FoobarPos.y + FoobarPos.h, 0x5eaaf7, 30)
        ;MouseMove Px, Py, 0
        ;sleep(1500)

        if !FindColor{
            attempts--
            if attempts = 0 {
                SendInput KS_Premiere.Player.Transform ; Deactivate the Transform tool.
                BlockInput("MouseMoveOff")
                MsgBox("Failed : FindColor Not Found", Err)
                Exit
            }
            else
                goto Restart
        } else {
            ;tooltip "FindColor Found"
            ; Move the mouse to the center of the found colored pixel (value).
            MouseMove Px+5, Py+5, 0 
            Sleep(5)
            
            ; Simulate a left click down (starting a drag operation for value scrubbing).
            Click "Left", , , , "Down"
            Sleep(12)
            
            BlockInput("MouseMoveOff") ; Allow user mouse movement now that the drag is initiated.
            
            ; Wait for the user to confirm (Enter) or cancel (Escape/Click) the drag-scrubbing.
            WaitForUserConfirm("Enter", "Escape", "LButton", "RButton", "MButton")
            
            ; Toggle the Transform tool off.
            SendInput KS_Premiere.Player.Transform
            Sleep(100)
            
            ; Release the mouse button (if still held down from the Click "Down" command)
            Click "Left", , , , "Up" 
            ; Restore the initial mouse position and return.
            return MouseMove(xStart, yStart)
        }
    }

    /**
     * @static
     * Activates the Transform control overlay in the Program Monitor, confines the mouse to the monitor,
     * and waits for the user to stop the interaction.
     * @returns {void}
     */
    static Transform() {
        CoordMode "Pixel", "Window"
        CoordMode "ToolTip", "Window"
        CoordMode "Mouse", "Window"

        MouseGetPos &xStart, &yStart ; Save initial mouse position.

        ClassPanel := Panel.ClassNN("Player") ; Get coordinates of the Program Monitor panel.
        Sleep(33)

        ; Move the mouse to the center of the Program Monitor.
        MouseMove ClassPanel.x + ClassPanel.w // 2, ClassPanel.y + ClassPanel.h // 2
        ; Activate the Transform overlay (shows handles for Position/Scale/Rotation).
        SendInput KS_Premiere.Player.Transform

        Loop {
            ; Confine the mouse cursor strictly to the Program Monitor area during the transform operation.
            ClipCursor({ x1: ClassPanel.x, y1: ClassPanel.y, x2: ClassPanel.x + ClassPanel.w, y2: ClassPanel.y + ClassPanel.h })
            ToolTip "Appuie sur ESC/ENTER pour stop." ; User instruction (in French, should be translated).
            
            ; Exit the loop if the user presses Escape or Enter.
            if GetKeyState("Esc") OR GetKeyState("Enter")
                break
            sleep(33)
        }
        
        ClipCursor() ; Release the cursor confinement.
        ToolTip ; Hide the instruction tooltip.
        Sleep(5)
        
        MouseMove xStart, yStart ; Restore the mouse position.
        SendInput KS_Premiere.Player.Transform ; Deactivate the Transform overlay.
        Sleep(66)
        return
    }
}

/**
 * @function FindImage
 * Performs an image search within a specified window area using the provided image file.
 * NOTE: This function is expected to be defined globally or within the class scope.
 * @param {string} imageName - The name of the image file (e.g., 'Position.png').
 * @param {number} x - The starting X-coordinate for the search area (Window relative).
 * @param {number} y - The starting Y-coordinate for the search area (Window relative).
 * @param {number} w - The width of the search area.
 * @param {number} h - The height of the search area.
 * @param {number} [shade=100] - The allowed color variation/shading for the search (*N option).
 * @param {string} [picturePath=fpath.ImageSearch] - The path to the image directory.
 * @param {number} [attempts=3] - Number of search attempts (currently unused inside the function).
 * @returns {Object|void} An object containing the image's X/Y coordinates on success, or void on failure.
 */
FindImage(imageName, x, y, w, h, shade := 100, picturePath := A_Path.ImageSearch, attempts := 3){
    ; ImageSearch returns 0 (found), 1 (not found), or 2 (error).
    FindImage := ImageSearch(&ImageX, &ImageY, x, y, x + w, y + h, "*" shade " " picturePath "\" imageName)
    if !FindImage {
        MsgBox("Failed finding picture.", Err)
        Exit
    }
    else {
        ImagePos := {X: ImageX, Y: ImageY}
        return ImagePos
    }
}

//// Panel.ahk

#Requires AutoHotkey v2.0

/**
 * @class Panel
 * Provides static methods for managing focus and retrieving window/control information 
 * for specific panels within Adobe Premiere Pro.
 * NOTE: Relies on external hotkey definitions in KS_Premiere.SelectPanel.
 */
class Panel {
    /**
     * @static
     * Focuses a specified panel in Premiere Pro by sending its corresponding hotkey.
     * Optionally performs a 'Reset' sequence to ensure the key is registered.
     * @param {string} Name - The name of the panel to focus ("Effects", "EffectControls", "Player", "Timeline", "Bin").
     * @param {boolean} [Reset=true] - If true, performs a double-tap on the 'Effects' hotkey first to ensure focus is released/reset.
     * @returns {void}
     */
    static Focus(Name, Reset := true) {
        if Reset {
            ; Send 'Effects' hotkey twice with a short delay to reset the active panel focus.
            SendInput KS_Premiere.SelectPanel.EffectControls
            Sleep(12)
            SendInput KS_Premiere.SelectPanel.EffectControls
            Sleep(5)
        }
        ; If the target is 'Effects', the reset sequence already focused it, so return.
        if Name = "EffectControls"
            return
        ; Send the specific hotkey for the requested panel.
        else if Name = "Effects"
            SendInput KS_Premiere.SelectPanel.Effects
        else if Name = "Player"
            SendInput KS_Premiere.SelectPanel.Player
        else if Name = "Timeline"
            SendInput KS_Premiere.SelectPanel.Timeline
        else if Name = "Bin"
            SendInput KS_Premiere.SelectPanel.Bin
        return
    }
    
    /**
     * @static
     * Focuses a panel and attempts to retrieve the ClassNN, screen coordinates, and dimensions of its content control.
     * Currently only fully implemented for "EffectControls".
     * @param {string} Name - The name of the panel (e.g., "EffectControls").
     * @param {number} [attempts=3] - Number of times to retry retrieving the control information.
     * @returns {Object|string} An object with {ClassNN, x, y, w, h} (screen coordinates/dimensions) on success, or an empty string on failure.
     */
    static ClassNN(Name, attempts := 3) {
        classNN := ""
        this.Focus(Name) ; Focus the target panel.
        Sleep(33)
        
        while (attempts > 1 or classNN = "") {
            attempts--
            try {
                ; Get the handle of the currently focused control within the active window ("A").
                hCtrl := ControlGetFocus("A")
                if !hCtrl
                    throw Error("No control focused")
                
                ; Retrieve the ClassNN (Class Name and Instance Number) for the focused control.
                classNN := ControlGetClassNN(hCtrl)
                if !classNN
                    throw Error("ClassNN not found")
                
                ; Get the position and size of the control, relative to the window.
                ControlGetPos &cx, &cy, &cw, &ch, classNN, "A"
                
                ; Get the position of the entire Premiere Pro window.
                WinGetPos &wx, &wy,,, "A"
                
                ; Calculate the control's absolute screen coordinates.
                globalX := (wx + cx)
                ; Add an offset (+55) to the Y coordinate, typically to skip the window's title bar/tabs 
                ; and ensure the coordinate starts within the panel's content area.
                globalY := (wy + cy) + 55 
                ; Comment: 'dunno why, but +50 seems to be needed for image search to work...'
                
                ; Return the control information.
                return {
                    ClassNN: classNN,
                    x: globalX,
                    y: globalY,
                    w: cw,
                    h: ch
                   }
                    
                } catch {
                    Sleep(25)
                    continue ; Retry the loop on failure.
                }
            }
            MsgBox "ClassNN not found for " Panel
            return ""
        ; Other panels would require their own specific ClassNN retrieval logic here.
    }
}

//// Paste.ahk

#Requires AutoHotkey v2.0

; I'm very proud of this one.
; I noticed, using clipboard analysis tools, that when decrypting information
; copied in Premiere Pro that are only usable within it (If you try to copy/paste keyframes 
; into some text app, it will paste nothing), we could distinguish one copied element from another.

; More precisely, we can decrypt and deduce if the copied element is:
; ¬† A timeline item (clip)
; ¬† A "Bin" panel item (project item)
; ¬† One or more keyframes

; The final goal of this function is to be able to copy/paste keyframes without needing
; to be focused on the effects panel. We will force the focus and paste the keyframes.

; USE CASE :
; You have a Transform effect, premade with custom velocity on keyframes, and you want to copy paste it.
; Select and copy your keyframe, use "LButton" (which is for me another ahk script that move my playhead on the mouse)
; and now, you can "^v" as you move on the timeline with your mouse to set up your keyframe
; without needing another input from you to put focus on "Effect Controls", which is needed to copy/paste keyframes.

/**
 * @function Paste
 * Smart Paste function for Adobe Premiere Pro. It detects the type of content
 * currently in the clipboard (Keyframes, Clip, or Project Item) based on the presence 
 * of custom clipboard formats. It forces focus to the 'Effect Controls' panel 
 * ONLY if keyframes are detected, allowing the user to paste keyframes without
 * manually focusing the panel.
 * NOTE: Relies on the external method Panel.Focus().
 * @returns {void}
 * @platform Adobe Premiere Pro
 */
Paste() {
    ; Custom clipboard format strings used by Premiere Pro to identify non-standard copied content.
    TrackItem := "PProAE/Exchange/TrackItem" ; Clipboard format for a selected clip on the timeline.
    ProjectItem := "PProAE/Exchange/ProjectItem" ; Clipboard format for an item in the Project/Bin panel.
    
    ; 1. Register the IDs of the formats to check
    ; DllCall("RegisterClipboardFormat") returns the ID associated with the format name.
    TrackItemID := DllCall("RegisterClipboardFormat", "Str", TrackItem)
    ProjectItemID := DllCall("RegisterClipboardFormat", "Str", ProjectItem)
    
    ; 2. Check for the presence of the formats
    ; IsClipboardFormatAvailable() returns 1 (True) if the format is present, 0 (False) otherwise.
    
    IsTrackItem := DllCall("IsClipboardFormatAvailable", "UInt", TrackItemID)
    IsProjectItem := DllCall("IsClipboardFormatAvailable", "UInt", ProjectItemID)
    
    ; Check the unique signature for keyframes: Absence of both TrackItem and ProjectItem.
    If (!IsTrackItem && !IsProjectItem)
    {
        ; Keyframes detected: The system clipboard contains a Premiere-specific keyframe format 
        ; that is NOT flagged by the clip or project item formats.
        
        Tooltip "Keyframe Detected"
        ; Force focus to the Effect Controls panel, as keyframe pasting requires it.
        Panel.Focus("EffectControls")
        sleep(5)

        ; Send the paste command (Ctrl+V). Use SendEvent for better timing control.
        SendEvent("{Ctrl Down}v{Ctrl Up}")
        return
    }
    Else
    {
        ; If either format is present, the content is a standard clip or project item. Paste normally.
        SendEvent("{Ctrl Down}v{Ctrl Up}")
        return
    }
}

//// Project.ahk

#Requires AutoHotkey v2.0

/**
 * @class Project
 * Class to manage and interact with Premiere Pro Project-level functions,
 * primarily focusing on project name extraction and activation.
 * NOTE: Assumes Application_Class.PremierePro.winClass is defined elsewhere.
 */
class Project {

    /**
     * @static
     * Gets the name of the main active project in Premiere Pro.
     * The Bin panel is focused before extraction to ensure the correct window is active/targeted.
     *
     * @returns {string} The base name of the active project file (e.g., "ActiveOpenedProject").
     */
    static A_ThisProject {
        get {
            Panel.Focus("Bin") ; Ensure the Bin panel is active before reading the window title.
            return this.GetActive()
        }
    }

    /**
     * @static
     * Gets the active Premiere Pro project's base name from the main window title.
     * This relies on the main Premiere Pro window title format.
     *
     * @returns {string|number} The base project name, or an error message box result if extraction fails.
     */
    static GetActive() {
        ; Get the main Premiere Pro window handle using its defined class.
        /** @type {number} */
        Premiere := WinExist(Application_Class.PremierePro.winClass)
        /** @type {string} */
        FullTitle := WinGetTitle(Premiere)
        ; Expected format example: "Adobe Premiere Pro {VER} - D:\User\Projects\ActiveOpenedProject.prproj *"
        
        ; RegEx to extract the project name without the extension.
        ; .*: Matches the beginning of the title.
        ; \\: Matches the final backslash preceding the filename path separator.
        ; (.+?): Capture group 1. Captures one or more characters non-greedily (the project name).
        ; \.prproj: Matches the file extension.
        ; \s*\**$: Matches optional spaces and the optional asterisk (*), followed by the end of the string.
        /** @type {string} */
        RegEx := ".*\\(.+?)\.prproj\s*\**$"
        
        ; Match the pattern against the window title.
        if RegExMatch(FullTitle, RegEx, &Match) {
            /** @type {string} */
            ActiveProject := Match[1]
            return ActiveProject
            ; Returns: "ActiveOpenedProject"
        } else {
            return MsgBox("Error: Could not extract active project name from window title.")
        }
    }

    /**
     * @static
     * Cycles through the Bin controls (open projects/shortcuts) in the Project Panel 
     * using the 'Bin' panel hotkey to find and focus the bin corresponding to the specified project name.
     *
     * @param {string} [ProjName=A_ThisProject] The base name of the project/bin to activate.
     * @returns {string|number} Returns a text string indicating success or failure, potentially with debug info.
     */
    static Activate(ProjName := this.A_ThisProject) {
        
        ; 1. Focus the Bin panel to start the focus cycle.
        Panel.Focus("Bin")
        Sleep(50)
        
        ; Array to store the ClassNN of visited controls to detect a full cycle (end of list).
        /** @type {string[]} */
        AllBins := []
        
        Loop {
            ; 2. Get the ClassNN of the currently focused control.
            /** @type {string} */
            CurrentBinClassNN := ControlGetClassNN(ControlGetFocus("A"))
            
            ; 3. Cycle check: If this ClassNN is already in AllBins, we've completed a full cycle.
            for _, StoredBin in AllBins {
                if (CurrentBinClassNN == StoredBin) {
                    ; Cycle detected, bin not found.
                    /** @type {string} */
                    ResultText := "Failure: Bin cycle is complete. The bin '" ProjName "' was not found."
                    ResultText .= "`n`nClassNN at failure: " CurrentBinClassNN
                    ResultText .= "`nNumber of Bins visited: " AllBins.Length
                    return ResultText
                }
            }
            
            ; Add the current ClassNN to the list of visited bins.
            AllBins.Push(CurrentBinClassNN)
            
            ; 4. Get the name of the active project/bin (based on the window title)
            /** @type {string|number} */
            ActiveName := this.GetActive()
            
            ; 5. Check the return from GetActive(). If it's an error message, stop.
            if (!ActiveName || InStr(ActiveName, "Error:")) {
                ; If GetActive returned an error message, treat it as a failure.
                /** @type {string} */
                ResultText := "Failure: Project.GetActive() encountered an error during name extraction. Stopping search."
                ResultText .= "`nLast ClassNN: " CurrentBinClassNN
                return ResultText
            }
            
            ; 6. Success check
            if (ActiveName == ProjName) {
                /** @type {string} */
                ResultText := "Success: Bin '" ProjName "' found and focused!"
                ResultText .= "`n`nClassNN found: " CurrentBinClassNN
                ResultText .= "`nNumber of Bins visited: " AllBins.Length
                return ResultText
            }
            
            ; 7. Move to the next bin
            Sleep(5)
            ; Use Panel.Focus("Bin", false) to send the hotkey again without the reset, 
            ; which in Premiere Pro cycles focus among controls within the panel (the opened bins/projects).
            Panel.Focus("Bin", false)
            Sleep(100)
        }
    }

}


/**
 * @class Bin
 * Class to manage and interact with Premiere Pro Bins (or project panels/shortcuts).
 * Works with imported Shortcut Projects as well.
 */
class Bin {
    /**
     * @static
     * Attempts to cycle the focus to a specific Bin (or opened project shortcut) index in the Project Panel.
     *
     * @param {number} Index The 1-based index of the Bin to focus. Must be 1 or higher.
     * @returns {number|void} Returns an error message box if the index is invalid, otherwise void.
     */
    static Focus(Index) {
        if (Index < 1) {
            return MsgBox("Error: Index must be 1 or higher.")
        }

        /** @type {string[]} */
        AllBins := []

        ; 1. Ensure the Bin panel is focused. (Panel.Focus is assumed to be defined elsewhere.)
        Panel.Focus("Bin")
        Sleep(50)

        ; Get the ClassNN of the control currently focused (expected to be Bin 1).
        /** @type {string} */
        FirstBin := ControlGetClassNN(ControlGetFocus("A"))
        AllBins.Push(FirstBin)

        ; Cycle focus (Index - 1) times to reach the target Bin index.
        Loop (Index - 1) {
            /** @type {string} */
            PrevBin := ControlGetClassNN(ControlGetFocus("A"))
            ; Store the current control's ClassNN for cycle detection later.
            AllBins.Push(PrevBin)
            
            Sleep(5)
            ; Cycle focus to the next Bin control without resetting the main Bin panel focus.
            Panel.Focus("Bin", false)
            Sleep(100) ; Small pause between key presses
        }
    
        ; Get the ClassNN of the final focused control.
        /** @type {string} */
        FinalBin := ControlGetClassNN(ControlGetFocus("A"))

        /** @type {boolean} */
        IsUnique := true

        ; Check if the FinalBin control is a duplicate of any previously visited control,
        ; indicating a failure to move to a new unique control (e.g., end of the list/cycle).
        for _, StoredBin in AllBins {
            ; Strict comparison of values
            if (FinalBin == StoredBin) {
                IsUnique := false ; FinalBin is NOT unique, a cycle/failure is detected.
                break ; Exit the loop as soon as a duplicate is found.
            }
        }
    
        /** @type {string} */
        /** @type {string} */
        ControlList := "FirstBin: " FirstBin '`n'
        ControlList .= "FinalBin: " FinalBin '`n' 
        ControlList .= "Index demand√©: " Index '`n'
        
        if (IsUnique) {
            ; Success: FinalBin is different from all previously recorded controls.
            MsgBox("Success (UNIQUE Final Control):`n" ControlList)
        } else {
            ; Failure: FinalBin is identical to an earlier control (cycle detected).
            MsgBox("Failure (NON-UNIQUE Final Control - Cycle Detected): `n" ControlList)
        }
    }
}

//// TrueCtrlBackspace.ahk

#Requires AutoHotkey v2.0

TrueCtrlBackspace() {
    SendInput "^+{Left}"
    sleep 50
    SendInput "{Backspace}"

}

//// TrueFullscreen.ahk

#Requires AutoHotkey v2.0

/**
 * @function TrueFullscreen
 * Toggles the "True Fullscreen" view in Premiere Pro for the currently focused panel.
 * This is typically the unmodifiable Adobe shortcut (Ctrl + Backslash on US keyboards).
 * It automatically switches the keyboard layout to English (en) before sending the hotkey,
 * and restores the original layout afterward, ensuring the hotkey executes correctly
 * regardless of the user's current keyboard language (e.g., French Azerty).
 * * @param {string} VKSC_Code - The Virtual Key/Scan Code string representing the backslash/asterisk key 
 * on a US keyboard (e.g., "SC02B" for the key that sends Backslash/Asterisk).
 * @returns {void}
 * @requires Panel.Focus() - To ensure the target panel (e.g., Effect Controls/Player) is active.
 * @requires Language.Set(), Language.Get.ID(), Language.Get.Name() - External functions for keyboard language management.
 * @platform Adobe Premiere Pro
 */
TrueFullscreen(VKSC_Code) {
    ; 0. Ensure a panel is focused, often Effect Controls (Program Monitor).
    Panel.Focus("EffectControls")
    sleep 33
    
    ; 1. Save the current keyboard language ID and Name.
    prevLangRaw := Language.Get.ID()
    prevLangName := Language.Get.Name(prevLangRaw)
    
    ; 2. Switch the keyboard layout to English (US) to guarantee the hotkey is recognized by Premiere.
    Language.Set("en")
    sleep 5
    newLangRaw := Language.Get.ID()
    newLangName := Language.Get.Name(newLangRaw)
    tooltip "Keyboard Switched to: " newLangName
    sleep 5
    
    ; 3. Execute the True Fullscreen hotkey: {LCtrl} + {*}
    ; The code "<^{" VKSC_Code "}" sends LCtrl + the specified key code,
    ; which Premiere Pro expects from an English layout (e.g., Backslash / Asterisk key).
    Send "<^{" VKSC_Code "}"
    sleep 650
    ; Send it again to exit fullscreen immediately if needed, or just to ensure the first command registered.
    Send "<^{" VKSC_Code "}"
    sleep 5
    ; Note: The sleep time (650ms) is crucial to allow the screen to switch.


    
    ; 4. Restore the previous keyboard language layout.
    Language.Set(prevLangRaw)
    
    ; 5. Debug tooltip for restored language confirmation.
    tooltip "Keyboard restored to: " prevLangName
}

//// Windows_Hotkeys.ahk

/*************************************************************************************************************
**************************************************************************************************************
                                                @README
**************************************************************************************************************
*************************************************************************************************************/
/**
¬†* Some windows default hotkey are awfull and useless. Like if you do in this right order :
¬†* {LWin} + {LAlt} + {LShift} + {LCtrl}, it will open "https://m365.cloud.microsoft/?from=OfficeKey"
¬†* because microsoft want to reminds you that your computer is not yours. Lol.
¬†* I tried everything, and you can still have this F*CKING page showing up, so if you want to remove it
¬†* completly, use Regedit (you should have a warning box when you launch my script, if not then : )
¬†*¬†
¬†* Open CMD as admin and write down :
¬†* REG ADD HKCU\Software\Classes\ms-officeapp\Shell\Open\Command /t REG_SZ /d rundll32
¬†*¬†
¬†* Not harmfull at all, will only remove THIS microsoft shortcut DEFINITELY. Be sure before doing so.
¬†*¬†
¬†*/

/*************************************************************************************************************
**************************************************************************************************************
                                                    @MOUSE
**************************************************************************************************************
*************************************************************************************************************/

Mbutton::{
    Window.Move "MButton"
    GUI_Debug.ReturnDebug "{MButton}", "WindowMover()", true
}

!Mbutton::{
    Window.Resize "MButton"
    GUI_Debug.ReturnDebug "{Alt} + {MButton}", "WindowResizer()", true
}



;@_WheelLeft
F13::{
    Komorebic("cycle-move next", &Result)
    GUI_Debug.ReturnDebug "{WheelLeft} := {F13}", Result, true
}

;@_WheelRight
F14::{
    Komorebic("cycle-move previous", &Result)
    GUI_Debug.ReturnDebug "{WheelRight} := {F14}", Result, true
}


XButton1::{
    SendInput("{Delete}")
    GUI_Debug.ReturnDebug "{XButton1}", "SendInput() => {Delete}", true
}

^XButton1::{
    SendInput("^{Delete}")
    GUI_Debug.ReturnDebug "{Ctrl} + {XButton1}", "SendInput() => ^{Delete}", true
}

+XButton1::{
    SendInput("+{Delete}")
    GUI_Debug.ReturnDebug "{Shift} + {XButton1}", "SendInput() => +{Delete}", true
}



XButton2::{
    SendInput("{Enter}")
    GUI_Debug.ReturnDebug "{XButton2}", "SendInput() => {Enter}", true
}

^XButton2::{
    SendInput("^{Enter}")
    GUI_Debug.ReturnDebug "{Ctrl} + {XButton2}", "SendInput() => ^{Enter}", true
}


+XButton2::{
    SendInput("+{Enter}")
    GUI_Debug.ReturnDebug "{Shift} + {XButton2}", "SendInput() => +{Enter}", true
}

            /*************************************************************************************
                                                    @MXGESTURES
            *************************************************************************************/
/**
¬†* @NOTES
¬†* FOR MX MASTER USER :
¬†* Dunno why, but WheelRight/WheelLeft on MX Master is pretty bad recognized by AHK.,
¬†* Tried to assign "Launch_App1" and "Launch_App2", doesn't recognize it,
¬†* But "Launch_Mail" and "Launch_Media" work ?? Wtf logitech ??
¬†* I don't like it, so I decided to use F13 and F14.
 * If you have some problem with using these, because it open a f*cking office page,
 * go see @README at the top page.
**/

; Move windows across workspaces
;@_MXGestureLeft
+!#Down::{
    Komorebic("cycle-move-to-workspace previous", &Result)
    GUI_Debug.ReturnDebug "{Shift} + {MXGestureLeft} := #+!^{Down}", Result, true
}

;@_MXGestureRight
+!#Up::{
    Komorebic("cycle-move-to-workspace next", &Result)
    GUI_Debug.ReturnDebug "{Shift} + {MXGestureRight} := #+!^{Up}", Result, true
}

;Move windows across monitor
;@_MXGestureLeft
^!#Down::{
    Komorebic("cycle-move-to-monitor previous", &Result)
    GUI_Debug.ReturnDebug "{Ctrl} + {MXGestureLeft} := #+!^{Down}", Result, true
}

;@_MXGestureRight
^!#Up::{
    Komorebic("cycle-move-to-monitor next", &Result)
    GUI_Debug.ReturnDebug "{Ctrl} + {MXGestureRight} := #+!^{Up}", Result, true
}

;Change Workspace
;@_MXGestureLeft
#!Down::{
    Komorebic("focus-monitor 0")
    Sleep(33)
    Komorebic("cycle-workspace previous", &Result)
    GUI_Debug.ReturnDebug "{MXGestureLeft} := #!{Down}", Result, true
}

;@_MXGestureRight
#!Up::{
    Komorebic("focus-monitor 0")
    Sleep(5)
    Komorebic("cycle-workspace next", &Result)
    GUI_Debug.ReturnDebug "{MXGestureRight} := #!{Up}", Result, true
}

;@_MXGesturePress
Appskey::{
    Komorebic("toggle-workspace-layer", &Result)
    GUI_Debug.ReturnDebug "{MXGesturePress} := {AppsKey}", Result, true
}




; eager-focus
;ocus the first managed window matching the given exe


/*************************************************************************************************************
**************************************************************************************************************
                                                    @KEYBOARD
**************************************************************************************************************
*************************************************************************************************************/

::remi@::remilapute6@gmail.com
::vg2002@::valentin.gerome2002@gmail.com
::vg20@::valentingrome20@hotmail.fr
::vg0@::valentingrome0@hotmail.fr
::contact@::kaesis.contact@gmail.com

#(::Application.Window(Application_Class.Notion.winTitle, Application_Class.Notion.path)
#&::Application.Window(Application_Class.Edge.winTitle, Application_Class.Edge.path)
#√©::Application.Window(Application_Class.Explorer.winClass, Application_Class.Explorer.path)
#"::Application.Window(Application_Class.Discord.winTitle, Application_Class.Discord.path)
#'::Application.Window(Application_Class.Code.winTitle, Application_Class.Code.path)

;Tab & &::Application.Window(Application_Class.PremierePro.winTitle, Application_Class.PremierePro.path)
;Tab & √©::Application.Window(Application_Class.AfterFx.winTitle, Application_Class.AfterFx.path)
;Tab & "::Application.Window(Application_Class.Photoshop.winTitle, Application_Class.Photoshop.path)
;Tab & '::Application.Window(Application_Class.Illustrator.winTitle, Application_Class.Illustrator.path)
;Tab & (::Application.Window(Application_Class.Audition.winTitle, Application_Class.Audition.path)
;Tab & -::Application.Window(Application_Class.MediaEncoder.winTitle, Application_Class.MediaEncoder.path)

;Tab::Tab;Important, if you delete that line, the above hotkeys will over-ride the default "{Tab}" button
;and doing like "{Alt} + {Tab}" will not work anymore.

#space::{
    Language.Switch("fr", "en")
    GUI_Debug.ReturnDebug "{Win} + {Space}", "SwitchLanguage() => Switch between 'fr' and 'en'", true
}

#¬≤::{
    Terminal("Deepr Terminal", "wt.exe", 3, 1200, 600, 300)
    GUI_Debug.ReturnDebug "{Win} + {¬≤}", "Terminal() => Run/Focus Deepr Terminal", true
}

#z::{
    AlwaysOnTop(Sound := true)
    GUI_Debug.ReturnDebug "{Win} + {z}", "AlwaysOnTop()", true
}

#f::{
    Komorebic("toggle-monocle")
    GUI_Debug.ReturnDebug "{Win} + {f}", "Komorebic() => 'toggle-monocle'", true
}

#v::{
    Komorebic("toggle-float")
    GUI_Debug.ReturnDebug "{Win} + {v}", "Komorebic() => 'toggle-float'", true
}

#^r::{
    Komorebic("retile")
    GUI_Debug.ReturnDebug "{Win} + {Ctrl} + {r}", "Komorebic() => 'retile'", true
}


;#b:: {
;resolutions := [[810, 1440], [800, 800], [1400, 1400]]
;
;hwnd := WinActive("A")
;if !hwnd
;return
;
;; R√©cup√®re les dimensions actuelles
;WinGetPos(&x, &y, &w, &h, hwnd)
;
;; Trouve l'index de la r√©solution actuelle ou la plus proche
;idx := 0, minDiff := 1e9
;loop resolutions.Length {
;rw := resolutions[A_Index][1], rh := resolutions[A_Index][2]
;diff := Abs(w - rw) + Abs(h - rh)
;if diff < minDiff
;idx := A_Index, minDiff := diff
;}
;
;; R√©solution suivante (boucle circulaire)
;next := Mod(idx, resolutions.Length) + 1
;targetW := resolutions[next][1], targetH := resolutions[next][2]
;
;; Centre la fen√™tre
;posX := (A_ScreenWidth - targetW) // 2
;posY := (A_ScreenHeight - targetH) // 2
;
;WinMove(posX, posY, targetW, targetH, hwnd)
;}
;
;#c:: {
;hwnd := WinActive("A")
;if !hwnd
;return
;
;; R√©cup√©rer la taille actuelle de la fen√™tre
;WinGetPos(&winX, &winY, &winW, &winH, hwnd)
;
;; Taille de l'√©cran principal
;screenW := A_ScreenWidth
;screenH := A_ScreenHeight
;
;; Calcul des nouvelles positions (centr√©es)
;posX := (screenW - winW) // 2
;posY := (screenH - winH) // 2
;
;; Appliquer le d√©placement sans redimensionnement
;WinMove(posX, posY, , , hwnd)
;}




/*************************************************************************************************************
**************************************************************************************************************
                                                    @KEYPAD
**************************************************************************************************************
*************************************************************************************************************/

/*
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
*/

;@_PadKey1
Browser_Home::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace", false)
    GUI_Debug.ReturnDebug "{PadKey1} => {Browser_Home}", "Application.Window() => 'Z:\Workspace'", true
}

;@_PadKey2
Browser_Favorites::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\.Watchfolder", false)
    GUI_Debug.ReturnDebug "{PadKey2} => {Browser_Favorites}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\.Watchfolder'", true
}

;@_PadKey3
Browser_Search::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\.Renders", false)
    GUI_Debug.ReturnDebug "{PadKey3} => {Browser_Search}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\.Renders'", true
}

;@_PadKey4
Browser_Refresh::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Workspace\Productions\Premiere Pro\Sessions", false)
    GUI_Debug.ReturnDebug "{PadKey4} => {Browser_Refresh}", "Application.Window() => 'Z:\Workspace\Productions\Premiere Pro\Sessions'", true
}


/*
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
*/

;@_PadKey5
Launch_App1::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Files", false)
    GUI_Debug.ReturnDebug "{PadKey5} => {Launch_App1}", "Application.Window() => 'Z:\Files'", true
}

;@_PadKey6
Launch_App2::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Videos", false)
    GUI_Debug.ReturnDebug "{PadKey6} => {Launch_App2}", "Application.Window() => 'Z:\Videos'", true
}

;@_PadKey7
F15::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Pictures", false)
    GUI_Debug.ReturnDebug "{PadKey7} => {F15}", "Application.Window() => 'Z:\Pictures'", true
}

;@_PadKey8
F16::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Sounds", false)
    GUI_Debug.ReturnDebug "{PadKey8} => {F16}", "Application.Window() => 'Z:\Sounds'", true
}

/*
[ ][ ][ ][ ]
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
*/

;@_PadKey9
F17::{
    GUI_Debug.ReturnDebug "{PadKey9} => {F17}", "NONE", true
}

;@_PadKey10
F18::{
    GUI_Debug.ReturnDebug "{PadKey10} => {F18}", "NONE", true
}

;@_PadKey11
F19::{
    GUI_Debug.ReturnDebug "{PadKey11} => {F19}", "NONE", true
}

;@_PadKey12
F20::{
    GUI_Debug.ReturnDebug "{PadKey12} => {F20}", "NONE", true
}


/*
[‚ñ†][‚ñ†][‚ñ†][‚ñ†]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
[ ][ ][ ][ ]
*/

;@_PadKey13
F21::{
    Application.Window(Application_Class.Explorer.winClass, "Z:\Scripts", false)
    GUI_Debug.ReturnDebug "{PadKey13} => {F21}", "Application.Window() => 'Z:\Scripts'", true
}

;@_PadKey14
F22::{
    GUI_Debug.ReturnDebug "{PadKey14} => {F22}", "NONE", true
}

;@_PadKey15
F23::{
    GUI_Debug.ReturnDebug "{PadKey15} => {F23}", "NONE", true
}

;@_PadKey16
F24::{
    IsShow := GUI_Debug.Toggle()
    ; Mise √† jour facultative de la GUI de d√©bogage (Debug_Gui)
    if (IsShow) {
    ; Le Toggle a ferm√© la fen√™tre.
        GUI_Debug.ReturnDebug "{PadKey16} => {F24}", "GUI_Debug.Toggle() => Show Debug GUI", true
    } else {
    ; Le Toggle a lanc√© la fen√™tre.
        GUI_Debug.ReturnDebug "{PadKey16} => {F24}", "GUI_Debug.Toggle() => Hide Debug GUI", true
    }
}


            /*************************************************************************************
                                                @KEYPAD_SMALLWHEEL1
            *************************************************************************************/

Media_Prev::{
    Volume.Change("ChangeAppVolume", "msedge.exe", -0.02)
    GUI_Debug.ReturnDebug "{PadSmallWheel1 Left} => {Media_Prev}", "Volume.Change() => Edge -2%", true
}

Media_Play_Pause::{
    Send("{Media_Play_Pause}")
    GUI_Debug.ReturnDebug "{PadSmallWheel1 Pressed} => {Media_Play_Pause}", "SendInput() => {Media_Play_Pause}", true
}

Media_Next::{
    Volume.Change("ChangeAppVolume", "msedge.exe", +0.02)
    GUI_Debug.ReturnDebug "{PadSmallWheel1 Right} => {Media_Next}", "Volume.Change() => Edge +2%", true
}

            /*************************************************************************************
                                                @KEYPAD_SMALLWHEEL2
            *************************************************************************************/

Browser_Back::{
    GUI_Debug.ReturnDebug "{PadSmallWheel2 Left} => {Browser_Back}", "NONE", true
}

Browser_Stop::{
    SendInput("{Browser_Stop}")
    GUI_Debug.ReturnDebug "{PadBigWheel Pressed} => {Browser_Stop}", "SendInput() => {Browser_Stop}", true
}

Browser_Forward::{
    GUI_Debug.ReturnDebug "{PadSmallWheel2 Right} => {Browser_Forward}", "NONE", true
}

            /*************************************************************************************
                                                @KEYPAD_BIGWHEEL
            *************************************************************************************/

Volume_Down::{
    Send("{Volume_Down}")
    GUI_Debug.ReturnDebug "{PadBigWheel Left} => {Volume_Down}", "Volume => Mix Down", true
}

Volume_Mute::{
    IsClosed := Volume.SndVol.Toggle(2, 1000, 200, 80, 5)
    Button := "{Volume_Mute}"

    ; Mise √† jour facultative de la GUI de d√©bogage (Debug_Gui)
    if (IsClosed) {
    ; Le Toggle a ferm√© la fen√™tre.
        GUI_Debug.ReturnDebug "{PadBigWheel2 Pressed} => " Button, "Volume.SndVol.Init() => SndVol Ended", true
    } else {
    ; Le Toggle a lanc√© la fen√™tre.
        GUI_Debug.ReturnDebug "{PadBigWheel2 Pressed} => " Button, "Volume.SndVol.Init() => SndVol Started", true
    }
}

Volume_Up::{
    Send("{Volume_Up}")
    GUI_Debug.ReturnDebug "{PadBigWheel Right} => {Volume_Up}", "Volume => Mix Up", true
}


;List of most useless key
;1 = used by mouse
;2 = used by macropad
;0 = not used

;   Browser_Back                 |   2
;   Browser_Forward              |   2
;   Browser_Refresh              |   2
;   Browser_Stop                 |   2
;   Browser_Search               |   2
;   Browser_Favorites            |   2
;   Browser_Home                 |   2

;   Volume_Mute                  |   2
;   Volume_Down                  |   2
;   Volume_Up                    |   2

;   Media_Next                   |   2
;   Media_Prev                   |   2
;   Media_Play_Pause             |   2
;   Media_Stop                   |   0

;   Launch_Mail                  |   0
;   Launch_Media                 |   0
;   Launch_App1                  |   0
;   Launch_App2                  |   0

;   Help0    
;   AppsKey                      |   1
;   PrintScreen                  |   0
;   CtrlBreak                    |   0
;   Pause                        |   0

;Very hard to use key (bc it probably doesn't exist on most keyboards.)
;   Sleep

//// App_Class.ahk

#Requires AutoHotkey v2.0


class Application_Class {

    static WinStart := {
        fullName: "Start",
        winTitle: "ahk_class Windows.UI.Core.CoreWindow"
    }

    static OneCommander := {
        winTitle: "ahk_exe OneCommander.exe",
        path: "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\OneCommander\OneCommander.lnk"
    }


    static PremierePro := {
        winTitle: "ahk_exe Adobe Premiere Pro.exe",
        winClass: "ahk_class Premiere Pro",
        path: "C:\Program Files\Adobe\Adobe Premiere Pro 2025\Adobe Premiere Pro.exe"
    }

    static PremierePro_BETA := {
        winTitle: "ahk_exe Adobe Premiere Pro (Beta).exe",
        path: "C:\Program Files\Adobe\Adobe Premiere Pro (Beta)\Adobe Premiere Pro (Beta).exe"
    }

    static Resolve := {
        winTitle: "ahk_exe Resolve.exe",
        path: "C:\Program Files\Blackmagic Design\DaVinci Resolve\Resolve.exe"
    }

    static AfterFX := {
        winTitle: "ahk_exe AfterFX.exe",
        path: "C:\Program Files\Adobe\Adobe After Effects 2025\Support Files\AfterFX.exe"
    }

    static Illustrator := {
        winTitle: "ahk_exe Illustrator.exe",
        winClass: "ahk_class illustrator",
        path: "C:\Program Files\Adobe\Adobe Illustrator 2025\Support Files\Contents\Windows\Illustrator.exe"
    }

    static MediaEncoder := {
        winTitle: "ahk_class Adobe Media Encoder 2025",
        path: "C:\Program Files\Adobe\Adobe Media Encoder 2025\Adobe Media Encoder.exe"
    }

    static Audition := {
        winTitle: "ahk_exe Adobe Audition.exe",
        path: "C:\Program Files\Adobe\Adobe Audition 2025\Adobe Audition.exe"
    }

    static Photoshop := {
        winTitle: "ahk_class Photoshop",
        path: "C:\Program Files\Adobe\Adobe Photoshop 2025\Photoshop.exe"
    }

    static Explorer := {
        winTitle: "ahk_exe explorer.exe",
        winClass: "ahk_class CabinetWClass",
        path: "C:\Users\Default\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\File Explorer"
    }

    static Arc := {
        fullName: "Arc",
        winTitle: "ahk_exe Arc.exe",
        path: "C:\Users\Default\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Arc.exe"
    }

    static Edge := {
        fullName: "Microsoft Edge",
        winTitle: "ahk_exe msedge.exe",
        path: "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
    }

    static Blender := {
        winTitle: "ahk_exe blender.exe",
        path: "C:\Program Files\Blender Foundation\Blender 4.3\blender.exe"
    }

    static Code := {
        winTitle: "ahk_exe Code.exe",
        path: "C:\Users\Ephraem\AppData\Local\Programs\Microsoft VS Code\Code.exe"
    }

    static Voicemeeter := {
        winTitle: "ahk_exe voicemeeter8x64.exe",
        path: "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\VB Audio\VoiceMeeter\Voicemeeter Potato x64"
    }

    static Discord := {
        fullName: "Discord",
        winTitle: "ahk_exe Discord.exe",
        path: "C:\Users\Ephraem\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Discord Inc\Discord"
    }

    static Obsidian := {
        winTitle: "ahk_exe Obsidian.exe",
        path: "C:\Users\Ephraem\AppData\Local\Programs\obsidian\Obsidian.exe"
    }

    static Notion := {
        winTitle: "ahk_exe Notion.exe",
        path: "C:\Users\Ephraem\AppData\Local\Programs\Notion\Notion.exe"
    }

    static FlowLauncher := {
        winTitle: "Flow.Launcher.exe",
        path: "C:\Users\Ephraem\AppData\Local\FlowLauncher\Flow.Launcher.exe"
    }

}


//// AlwaysOnTop.ahk



AlwaysOnTop(Sound := true)
{
    ; WS_EX_TOPMOST est le style √©tendu pour AlwaysOnTop.
    ; Sa valeur est 0x8.
    HWND := WinGetID("A")
    ExStyle := WinGetExStyle(HWND)
    IsOnTop := (ExStyle & 0x8)
    
    If IsOnTop
    {
        ; Actuellement AlwaysOnTop, on le d√©sactive (0)
        WinSetAlwaysOnTop 0, HWND
        ; Bip pour indiquer la d√©sactivation
        if Sound
            SoundPlay A_Path.Sounds "\Button3.wav"
    }
    Else
    {
        ; N'est pas AlwaysOnTop, on l'active (1)
        WinSetAlwaysOnTop 1, HWND
        ; Bip pour indiquer l'activation
        if Sound
            SoundPlay A_Path.Sounds "\Button1.wav"
    }
}

//// Application.ahk

#Requires AutoHotkey v2.0

/************************************************************************
 * @description - Functions to run/focus/minimize applications based on window titles or criteria.
 * Original from JuanmaMenendez (https://github.com/JuanmaMenendez/AutoHotkey-script-Open-Show-Apps/blob/master/Open-Apps-and-Switch-opened-windows.ahk)
 * @STILL_IN_PROGRESS (BrowserApp untested yet, Title can be hard to use)
 ***********************************************************************/


; example:
; Application.Window("ahk_exe Adobe Premiere Pro.exe", "C:\Program Files\Adobe\Adobe Premiere Pro 2025\Adobe Premiere Pro.exe")

/**
 * @class Application
 * Provides static methods for managing application windows (launch, focus, minimize)
 * based on window criteria or specific application types (e.g., browsers, Explorer).
 */
class Application {
    /**
     * @description Toggles between Run/Minimize/Focus for a Chrome-based browser app (e.g., as a PWA).
     * This method currently relies on the more generic `Window` method.
     * @param {string} titlePart - A partial window title to match the existing window.
     * @param {string} url - The URL to open in app mode (e.g., 'https://mail.google.com/mail/').
     * @param {string} appPath - The full path to the browser executable (e.g., 'C:\Program Files\Google\Chrome\Application\chrome.exe').
     * @returns {void}
     * @example
     * Application.BrowserApp('Gmail', 'https://mail.google.com/mail/', 'C:\Program Files\Google\Chrome\Application\chrome.exe')
     */
    static BrowserApp(titlePart, url, appPath)
    {
        ; SetTitleMatchMode 2 is the default value for AHK v2.0 (TitleMatchMode "Contains").
        ; Construct the full command line to run the browser in PWA/App mode.
        compose := appPath . ' --app=' url
        ; Calls the generic Window method, using 'titlePart' as the window criterion and 'appPath' as the run command.
        ; NOTE: This call is likely intended to use `compose` as the run command for launching,
        ; but currently uses `appPath`, which runs the browser without the PWA argument unless
        ; the intention is to only match the running process.
        this.Window(titlePart, appPath) ; Note: titlePart is used here as winCriteria, which might be too broad.
    }


    /**
     * @description Toggles between Run/Minimize/Focus for an app using its window Title.
     * This method specifically enforces RegEx matching for the Title parameter.
     * @param {string} Title - The window title to match. Uses RegEx syntax (e.g., 'Microsoft.*Edge').
     * @param {string} AppAddress - The path/command to run the application (e.g., 'msedge.exe').
     * @returns {void}
     * @example
     * Application.Title('Microsoft.*Edge', 'msedge.exe')
     */
    static Title(Title, AppAddress)
    {
        ; A_TitleMatchMode defaults to "2" (Contains). Setting it explicitly to "2" here is redundant
        ; but included for clarity/legacy.
        A_TitleMatchMode := "2"
        SetTitleMatchMode "regEx" ; Temporarily switch to RegEx mode for Title matching.

        ; Check if the process exists (a rough proxy for the application being open).
        If ProcessExist(AppAddress) {
            ; If process exists, check if the window is currently active (using RegEx match on Title).
            If WinActive(Title) {
                WinMinimize(Title) ; Minimize if active.
            } else {
                WinActivate(Title) ; Activate if open but inactive.
            }
        } 
        ; If the process does not exist, attempt to run the application.
        else try {
            ; After running, activation will be handled automatically by the OS or the process itself.
            run AppAddress
        } catch as e {
            ; Display an error if the application cannot be launched.
            msgbox e . AppAddress
        }
        ; SetTitleMatchMode is NOT automatically reverted here; be cautious of side effects.
    }

/**
 * @description Toggles between Run/Minimize/Focus for an application based on a window criterion.
 * This is the core function for application toggling.
 * @param {string} winCriteria - The base criterion (e.g., 'ahk_exe Discord.exe', 'ahk_class CabinetWClass').
 * @param {string} runCommand - The command/path to run, also used to refine the window title search for Explorer.
 * @param {boolean} [force=false] - If true, ignores existing windows and forces a new application launch.
 * @returns {string|void} The action taken ("Minimize", "Activate", "Launch") or void on error.
 */
static Window(winCriteria, runCommand, force := false) {
    
    ; --- 1. DEFINE THE FULL WINDOW CRITERIA ---
    ; This section attempts to refine the criteria, especially for File Explorer windows.
    
    ; Build precise WinTitle criteria (especially for Explorer)
    WinTitleCriteria := ""
    ; Check if criteria includes Explorer class AND runCommand is a valid file/folder path.
    if (InStr(winCriteria, "CabinetWClass") && FileExist(runCommand)) {
        ; Extract the folder/file name for the title matching (Explorer window title usually contains this).
        SplitPath(runCommand, &FileName)
        WinTitleCriteria := FileName ; Search for a window title containing the folder name.
    }

    ; Combine the criteria: Base criterion OR the specific Explorer class.
    FullWinCriteria := (WinTitleCriteria ? 'ahk_class CabinetWClass' : winCriteria) ; The Title/Criteria for WinExist
    ; WinText is used for the folder name search (if it's an Explorer path).
    WinTextCriteria := WinTitleCriteria ? WinTitleCriteria : "" ; The partial title (WinText) for WinExist

    ; --- 2. CHECK FOR EXISTENCE / TOGGLE (unless forced) ---
    if !force && WinExist(FullWinCriteria, WinTextCriteria) {
        if WinActive(FullWinCriteria, WinTextCriteria) {
            WinMinimize(FullWinCriteria, WinTextCriteria)
            return "Minimize"
        } else {
            WinActivate(FullWinCriteria, WinTextCriteria)
            return "Activate"
        }
    } 
    
    ; --- 3. LAUNCH (if non-existent or forced) ---
    else try {
        ; NOTE: For Explorer (runCommand = a path), Run opens this path in a new window.
        Run(runCommand) ; Launch the application/path.
        
        ; Activation logic for the newly launched window.
        
        ; WinWait and activate only if NOT forced AND the command is not 'edge.exe' (specific exclusion).
        if (!force && !InStr(runCommand, 'edge.exe')) {
            WinWait(FullWinCriteria, WinTextCriteria) ; Wait for the window to appear.
            WinActivate(FullWinCriteria, WinTextCriteria) ; Activate the found window.
        }
        return "Launch"
    } catch as e {
        MsgBox('Error launching: ' . runCommand . '`nMessage: ' . e.Message)
        return
    }
}


    /**
     * @description Toggles between Run/Minimize/Focus for File Explorer, with an option to open a specific Path or find it in an existing tab.
     * NOTE: Requires Application_Class.Explorer.winClass and Application_Class.Explorer.path to be defined externally.
     * @param {string} [Path=""] - The path to open (file, folder, or drive). If empty, it toggles the default Explorer window.
     * @param {boolean|string} [NewTab=false] - If true, tries to open the path in a new tab. If "Actual", opens in the current tab. Defaults to false (new window or find existing).
     * @param {boolean} [ForceOpen=false] - If true, skips tab searching and forces opening the path (new tab or current tab).
     * @returns {void}
     * @example
     * Application.Explorer("Z:\Scripts", false) ; Toggle or open in new window
     * Application.Explorer("C:\Users\Name\Documents", true) ; Open path in a new tab
     */
    static Explorer(Path := "", NewTab := false, ForceOpen := false) {
        ; NOTE: Requires the existence of a global Application_Class object.
        local winCriteria := Application_Class.Explorer.winClass ; Expected to be 'ahk_class CabinetWClass'
        local runCommand := Application_Class.Explorer.path ; Expected to be 'explorer.exe' or default path
        local winID := WinExist(winCriteria)
        
        if (winID) {
            ; --- BASE LOGIC (Focus/Minimize) ---
            if (Path == "") {
                if WinActive(winCriteria) {
                    WinMinimize(winCriteria) ; <-- Minimize if already active
                    return
                } else {
                    WinActivate(winCriteria) ; <-- Activate if open but inactive
                    return
                }
            } else {

                ; If Path is NOT empty, continue with activation/tab management logic.
                ; Ensure the window is active for subsequent SendInput commands.
                if WinActive(winCriteria) {
                    ; If active and a path is specified, it seems the intention is to minimize it (exit 1).
                    ; This logic might be intended for a different workflow.
                    WinMinimize(winCriteria)
                    return msgbox("exit 1")
                } else {
                    WinActivate(winCriteria)
                    WinWaitActive(winCriteria)
                }

                ; If a path is specified, check if it's an existing tab
                local FullTitle := WinGetTitle(winID)
                
                ; 1. Tab Count Detection using RegEx.
                local Match := []
                ; Checks for the " and X more tabs" suffix in the title.
                local found := RegExMatch(FullTitle, " and (\d+) more tabs - File Explorer", &Match)
                
                ; numExtraTabs = Number of additional tabs. totalTabs = Total number of tabs (numExtraTabs + 1).
                local numExtraTabs := found ? Match[1] : 0 
                local totalTabs := numExtraTabs + 1

                ; Extract the last folder/file name from the Path.
                local folderName := RegExReplace(Path, ".*[\\/](.+)", "$1")
                
                ; Send a Tab press, often used to ensure the window is ready for hotkeys after activation/minimization.
                SendInput "{Tab}"
                BlockInput true ; Block user input during SendInput sequence.

                ; --- FORCE OPEN LOGIC ---
                if ForceOpen {
                    if NewTab = true {
                        ; Open path in a NEW tab (Ctrl+T, Alt+D for address bar, paste, Enter)
                        SendInput "^{t}"
                        Sleep 600 ; Wait for new tab to open
                        SendInput "!{d}"
                        
                        Sleep 200
                        SendInput Path
                        Sleep 100
                        SendInput "{Enter}"
                        BlockInput false
                        return
                    }

                    if NewTab = "Actual" {
                        ; Open path in the ACTUAL tab (Alt+D for address bar, paste, Enter)
                        SendInput "!{d}"
                        sleep 200
                        SendInput Path
                        Sleep 100
                        SendInput "{Enter}"
                        BlockInput false
                        return
                    }
                }
                
                ; --- TAB SEARCH LOGIC (if not forced and multiple tabs exist) ---
                if (totalTabs > 1) {
                    local targetFound := false
                    
                    ; Loop through all tabs (totalTabs times).
                    Loop totalTabs
                    {
                        ; 2. Get the ACTIVE tab's title (must be retrieved after each ^Tab).
                        local currentTitle := WinGetTitle(winCriteria)
                        
                        ; Clean the title: Remove multi-tab suffix and single-tab suffix.
                        local cleanTitle := RegExReplace(currentTitle, " and \d+ more tabs - File Explorer", "")
                        cleanTitle := RegExReplace(cleanTitle, " - File Explorer", "") 
                        
                        ; 3. Compare the active tab name with the searched path (folderName).
                        if (InStr(cleanTitle, folderName)) {
                            targetFound := true
                            WinActivate(winCriteria) ; Ensure the found tab remains active.
                            WinWaitActive(winCriteria)
                            break 
                        }

                        ; 4. Switch to the next tab (N-1 times).
                        if (A_Index < totalTabs) {
                            SendInput "^{Tab}" ; Ctrl+Tab
                            Sleep 200 ; Essential: Wait for the window title to update after tab switch.
                        }
                    }
                    
                    if (targetFound) {
                        BlockInput false
                        return ; Tab was found and activated.
                    } else {
                        ; Tab was not found in the loop. Open the path (new window/tab).
                        if NewTab = true {
                            ; Open path in a NEW tab
                            SendInput "^{t}"
                            Sleep 600
                            SendInput "!{d}"
                            
                            Sleep 200
                            SendInput Path
                            Sleep 100
                            SendInput "{Enter}"
                            BlockInput false
                            return
                        }

                        if NewTab = "Actual" {
                            ; Open path in the ACTUAL tab (overwrite current path)
                            SendInput "!{d}"
                            sleep 200
                            SendInput Path
                            Sleep 100
                            SendInput "{Enter}"
                        }

                        ; Fallback: Open in a NEW WINDOW (if NewTab was false/unspecified).
                        Run("explorer.exe " . Path)
                        BlockInput false
                        return
                    }
                    
                } else {
                    ; --- SINGLE-TAB MODE (totalTabs = 1) ---
                    BlockInput false
                    local singleTabName := RegExReplace(FullTitle, " - File Explorer", "")
                    
                    ; Check if the single active tab matches the path name.
                    if (InStr(singleTabName, folderName)) {
                        WinActivate(winCriteria) 
                        WinWaitActive(winCriteria)
                        BlockInput false
                        return ; Correct folder is already active.
                    } else {
                        ; Not the correct folder, open the path (new window/tab logic repeats).
                        if NewTab = true {
                            ; Open path in a NEW tab
                            SendInput "^{t}"
                            Sleep 600
                            SendInput "!{d}"

                            Sleep 200
                            SendInput Path
                            Sleep 100
                            SendInput "{Enter}"
                            BlockInput false
                            return
                        }
                        if NewTab = "Actual" {
                            ; Open path in the ACTUAL tab
                            SendInput "!{d}"
                            sleep 200
                            SendInput Path
                            Sleep 100
                            SendInput "{Enter}"
                        }
                        
                        ; Fallback: Open in a NEW WINDOW
                        Run("explorer.exe " . Path)
                        WinActivate(winCriteria) ; Activate the newly opened window/tab
                        WinWaitActive(winCriteria)
                        BlockInput false
                        return
                    }
                }
            }
        } 
        ; --- LAUNCH (if window does not exist) ---
        else try {
            ; Window does not exist, run the command (Path takes precedence for launching).
            local commandToRun := (Path != "") ? "explorer.exe " . Path : runCommand
            
            Run(commandToRun) ; Launch if not found
            
            ; Wait and activate the new window.
            WinWait(winCriteria)
            WinActivate(winCriteria)
            WinWaitActive(winCriteria)
            
            return
        } catch as e {
            MsgBox('Error launching: ' . (Path != "" ? Path : runCommand) . '`nMessage: ' . e.Message)
            return
        }
    }

}

//// ClassNN_toCoords.ahk

#Requires AutoHotkey v2.0

ClassNN_ToCoords(hwnd, x, y, w, h) {
    ; Convertir coords en √©cran
    pt := Buffer(8)
    NumPut("int", x, pt, 0), NumPut("int", y, pt, 4)
    DllCall("ClientToScreen", "ptr", hwnd, "ptr", pt)
        ;The ClientToScreen function converts the client-area coordinates of a specified point to screen coordinates.

    x_screen := NumGet(pt, 0, "int")
    y_screen := NumGet(pt, 4, "int")
    x_center := x_screen + w // 2
    y_center := y_screen + h // 2
    return { 
        x_screen: x_screen,
        y_screen: y_screen,
        x_center: x_center,
        y_center: y_center,
            }
}

//// ClipCursor.ahk

#Requires AutoHotkey v2.0

ClipCursor(rect := unset) {
    if IsSet(rect) {
        buf := Buffer(16)
        NumPut("int", rect.x1, buf, 0)
        NumPut("int", rect.y1, buf, 4)
        NumPut("int", rect.x2, buf, 8)
        NumPut("int", rect.y2, buf, 12)
        return DllCall("ClipCursor", "ptr", buf)
    } else {
        return DllCall("ClipCursor", "ptr", 0)
    }
}

//// FindCaret.ahk

#Requires AutoHotkey v2.0

FindCaret(timeoutMs := 700, showTooltip := true) {
    CoordMode "Caret", "Screen"
    attempts := 0
    interval := 33
    maxAttempts := timeoutMs // interval

    while (attempts < maxAttempts) {
        CaretGetPos(&x, &y)
        attempts++
        if (x != "" && y != "") {
            return {x: x, y: y}
        }
        sleep interval
    }

    if showTooltip
        SetTimer Tooltip.Bind("NO CARET FOUND"), -100
    return false
}

//// HandleKeyGestures.ahk

#Requires AutoHotkey v2.0

/**
 * @function CleanHotkey
 * @description Removes prefix/suffix modifiers from A_ThisHotkey (e.g., *, $, ~, #, ^, !, +, <, >)
 * to get the base key name (e.g., 'a', 'LButton').
 * @returns {String} The cleaned hotkey string.
 */
CleanHotkey() {
    ; Use a RegEx pattern to remove the common hotkey prefix/suffix symbols in AHK.
    return RegExReplace(A_ThisHotkey, "[*~$#^!+<>]")
}

/**
 * @function MultiAction
 * @description Manages a multi-action hotkey, supporting Single Press, Double Press, and Hold actions.
 * Actions are passed as function objects (or arrays of function objects) which receive
 * a Map object for passing state/data.
 *
 * @param {Array<Function>|Function|0} [Action_SinglePress=0] - Function(s) to execute on a single tap. If 0, defaults to pressing the key itself.
 * @param {Array<Function>|Function|0} [Action_DoublePress=0] - Function(s) to execute on a double tap.
 * @param {Array<Function>|Function|0} [Action_Hold=0]        - Function(s) to execute repeatedly while the key is held past the HoldedTimeout.
 * @param {Array<Function>|Function|0} [Action_Start=0]       - Function(s) to execute immediately upon key press (before any detection).
 * @param {Array<Function>|Function|0} [Action_End=0]         - Function(s) to execute after the main action (Single/Double/Hold) completes.
 * @param {Boolean} [SinglePressNoEnd=false]                  - If true, skips Action_End execution *only* for a Single Press.
 *
 * @returns {String} A comma-separated string of the action types triggered (e.g., "Action_SinglePress, Action_End"). Returns "None" if nothing triggered.
 */
HandleKeyGestures(Action_SinglePress := 0, Action_DoublePress := 0, Action_Hold := 0, Action_Start := 0, Action_End := 0, SinglePressNoEnd := false) {

    StartTime := A_TickCount
    ThisHotkey := CleanHotkey()
    HoldedAction := false
    ActionsTriggered := []      ; Array to store the names of triggered actions for the return string.
    Interval := 33              ; Sleep duration (ms) for internal loops, affects responsiveness.
    Timeout := 230              ; Max duration (ms) between key-up and key-down for Double Press detection.
    HoldedTimeout := 200        ; Min duration (ms) the key must be held to trigger Action_Hold.
    Actions := Map()            ; A Map object to pass state/data between different action functions.

    ; --- Utility Function to Build Return String (AHK v2.0 non-object method) ---
    BuildReturnString(ActionsArray) {
        ReturnString := ""
        Separator := ""
        for action in ActionsArray {
            ReturnString .= Separator action
            Separator := ", "
        }
        ; Return 'None' if empty, otherwise the constructed string.
        return ReturnString := (ReturnString = "" ? "None" : ReturnString)
    }

    ; --- Action Start Execution ---
    if Action_Start != 0 {
        ; Assuming Action_Start is a function object or an array of function objects.
        ; AHK v2.0 allows direct iteration over single functions/objects as if they were arrays of size 1.
        for fn in Action_Start {
            fn.Call(Actions) ; Execute the function, passing the state Map.
        }
        Sleep Interval
        ; Note: The name of the argument is not pushed to ActionsTriggered here in the original code.
    }

    ; --- Default SinglePress Setup ---
    ; If no single press action is provided, default to a function that returns the cleaned hotkey string.
    ; This is a placeholder for a 'do nothing' or 'send key' default action.
    if (Action_SinglePress = 0) {
        ; Use an array containing a lambda function that returns the key name.
        ; The original logic appears to intend this as a placeholder, perhaps for a future Send.
        Action_SinglePress := [(Actions) => CleanHotkey()]
    }

    ; --- Hold Detection Loop ---
    while GetKeyState(ThisHotkey, "P") { ; 'P' checks physical state of the key.
        Elapsed := A_TickCount - StartTime
        if Elapsed > HoldedTimeout {
            ActionsTriggered.Push("Action_Hold")
            HoldedAction := true
            ; Enter the dedicated hold loop once hold is detected
            while GetKeyState(ThisHotkey, "P") {
                if Action_Hold { ; Check if an Action_Hold function(s) was provided.
                    for fn in Action_Hold {
                        fn.Call(Actions)
                    }
                }
                Sleep Interval
            }
        }
        if HoldedAction {
            break ; Exit the initial detection loop if the hold was triggered.
        }
        ; Important: The original code is missing a Sleep/Wait here if the HoldedTimeout is not reached,
        ; which would lead to a near-instant single press if the key is released before the interval.
        ; However, due to the implicit 'break' when the key is released, it proceeds to the next block quickly.
    }

    ; --- Single/Double Press Handling ---
    if !HoldedAction {
        if (Action_DoublePress != 0) {
            ; Wait for the key to be released before looking for the second press.
            KeyWait(ThisHotkey)
            ; Check if the key is *not* currently pressed (it should have been released by now).
            if !GetKeyState(ThisHotkey, "P") {
                ; KeyWait for a second press (D=Down) within the Timeout duration.
                if KeyWait(ThisHotkey, "D T" Timeout / 1000) { ; AHK v2 requires Time in seconds.
                    ; Double Press Detected
                    for fn in Action_DoublePress {
                        fn.Call(Actions)
                    }
                    Sleep Interval
                    ActionsTriggered.Push("Action_DoublePress")
                } else {
                    ; Single Press Detected (Double press timed out)
                    for fn in Action_SinglePress {
                        fn.Call(Actions)
                    }
                    Sleep Interval
                    ActionsTriggered.Push("Action_SinglePress")
                }
            }
            ; If GetKeyState(ThisHotkey, "P") was true here, it means the key was still down
            ; after the initial KeyWait, which shouldn't happen unless KeyWait failed/was interrupted.
        } else {
            ; Simple Single Press if no Double Press action is defined (immediate execution).
            for fn in Action_SinglePress {
                fn.Call(Actions)
                Sleep Interval
            }
            ActionsTriggered.Push("Action_SinglePress")
        }
    }

    ; --- Intermediate Return Check ---
    ReturnString := BuildReturnString(ActionsTriggered)
    if (!HoldedAction and SinglePressNoEnd) {
        return ReturnString ; Exit immediately if it was a Single Press and SinglePressNoEnd is true.
    }

    ; --- Action End Execution ---
    if Action_End != 0 {
        for fn in Action_End {
            fn.Call(Actions)
        }
        Sleep Interval
        ActionsTriggered.Push("Action_End") ; Note: This action is pushed even if SinglePressNoEnd caused an early exit (only relevant if the function continued).
    }

    ; --- Final Return ---
    ReturnString := BuildReturnString(ActionsTriggered)
    return ReturnString
}

//// Komorebic.ahk

#Requires AutoHotkey v2.0

/**
 * @function Komorebic
 * Executes a command using 'komorebic.exe', the command-line client for the Komorebi tiling window manager.
 * The execution is performed hidden and silently on success.
 * @param {String} cmd The command string to be passed as an argument to komorebic.exe (e.g., 'focus-left').
 * @param {ByRef String} [Result] An optional output variable to store a success message.
 * @returns {void}
 */
Komorebic(cmd, &Result?) {
    try {
        ; Attempts to execute the command via komorebic.exe, hiding the command window.
        Run(format("komorebic.exe {}", cmd), , "Hide")
        ; If successful, store a confirmation message in the optional Result variable.
        Result := 'Komorebic => ' cmd
    } catch as e {
        ; If an error occurs (e.g., komorebic.exe not found in PATH), display an error message.
        return MsgBox('Error while trying to open "komorebic.exe".')
    }
}

//// Language.ahk

#Requires AutoHotkey v2.0
;by Moo-GH : https://github.com/moo-gh/windows-auto-language-switcher/blob/main/keyboard_language_switcher.ahk
;I only need the Keyboard Detection and Set Language part, it's insanely good.

/**
 * @class Language
 * Manages the setting, getting, and switching of the active keyboard input language.
 */
class Language {
    /**
     * @static
     * Sets the keyboard input language for the active window.
     * Note: This method currently uses a generic PostMessage that might not reliably set a specific language
     * based on the LanguageCode parameter for all contexts in AHK v2.0.
     * The original implementation likely had a different intent or context for the PostMessage.
     * @param {String} LanguageCode The hexadecimal string representation of the language ID (e.g., '409' for English).
     * @returns {void}
     */
    static Set(LanguageCode) {
        ; Adjusting the code to switch input languages
        ; NOTE: This specific PostMessage (0x50, 0, 0) is WM_INPUTLANGCHANGEREQUEST, which usually
        ; triggers a change to the *next* installed language, not necessarily the one specified by LanguageCode.
        ; The 'LanguageCode' parameter is currently unused in this implementation.
        PostMessage(0x50, 0, 0, , "A")  ; Send WM_INPUTLANGCHANGEREQUEST message to the active window (WinTitle "A")
    }

    /**
     * @static
     * Cycles through a list of languages, switching the active input language to the next one in the list.
     * @param {...String} Params A variadic array of hexadecimal language code strings to cycle through (e.g., '409', '40c').
     * @returns {void}
     */
    static Switch(Params*) {
        ; Retrieves the ID of the current active language layout.
        currentLang := this.Get.ID()
        if !currentLang
            return 0 ; Unable to retrieve the language ID, aborting switch.

        ; Creates an array from the language codes provided as parameters.
        langs := []
        for index, lang in Params
            langs.Push(lang)

        ; Finds the index of the current language in the array to determine the next one.
        nextIndex := 1  ; Default index (the first language) if the current language is not in the list.
        for index, lang in langs {
            if (lang = currentLang) {
                ; Move to the next language in the list, or wrap around to the beginning (index 1).
                nextIndex := (index < langs.MaxIndex()) ? index + 1 : 1
                break
            }
        }

        ; Changes the language to the next one in the determined sequence.
        this.Set(langs[nextIndex]) ; Calls the Set method to perform the actual switch.
        return
    }
    

    /**
     * @class Get
     * Provides static methods to retrieve information about the current keyboard layout/language.
     */
    class Get {
        /**
         * @static
         * Retrieves the hexadecimal ID of the active keyboard layout (HKL) for a given window.
         * The ID is masked to isolate the Language Identifier (LOWORD) part.
         * @param {AHK_Window} [hWnd=''] The window handle (Ptr) to check. Defaults to the active window.
         * @returns {String} The hexadecimal language ID string (e.g., '409'), or an empty string on failure.
         */
        static ID(hWnd := '') {
            (!hWnd) && hWnd := WinActive('A') ; Use the active window if no handle is provided.
            ; Get the thread ID of the window handle.
            threadId := DllCall('GetWindowThreadProcessId', 'Ptr', hWnd, 'UInt', 0)
            if (threadId = 0) {
                MsgBox("Failed to retrieve thread ID.")
                return ""
            }
            ; Get the keyboard layout handle (HKL) associated with the thread.
            lyt := DllCall('GetKeyboardLayout', 'Ptr', threadId, 'UInt')
            if (lyt = 0) {
                MsgBox("Failed to retrieve keyboard layout.")
                return ""
            }
            ; Mask the HKL (lyt) to extract the Language Identifier (LANGID), which is the low 16 bits,
            ; then format it as a hexadecimal string. (0x3FFF is used to mask the relevant bits).
            Return Format('{:#x}', lyt & 0x3FFF)
        }

        /**
         * @static
         * Retrieves the English name of the language associated with a given Language ID.
         * @param {UInt} langId The numerical Language Identifier (LANGID).
         * @returns {String} The English name of the language (e.g., 'English'), or an empty string if the call fails.
         */
        static Name(langId)  {
            LOCALE_SENGLANGUAGE := 0x1001 ; Constant for the language name in English.
            ; Get the required buffer size for the language name string.
            charCount := DllCall('GetLocaleInfo', 'UInt', langId, 'UInt', LOCALE_SENGLANGUAGE, 'UInt', 0, 'UInt', 0)
            ; Create a buffer with the necessary size (charCount * 2 bytes for WCHAR).
            localeSig := Buffer(size := charCount << 1)
            ; Get the actual language name string into the buffer.
            DllCall('GetLocaleInfo', 'UInt', langId, 'UInt', LOCALE_SENGLANGUAGE, 'Ptr', localeSig, 'UInt', size)
            ; Convert the buffer content (UTF-16 string) to an AHK string and return it.
            Return StrGet(localeSig)
        }


    }
}

//// Mouse.ahk

/**
 * @class Mouse
 * Provides static methods for interacting with the mouse position and the
 * corresponding window and control under the cursor.
 */

class Mouse {
    /**
     * Retrieves the coordinates of the mouse cursor, and the ID and control name
     * of the window under the cursor.
     *
     * **AHK 2.0 Usage:**
     * `pos := Mouse.Get()`
     * `MsgBox "Window ID: " pos.Id ", Control: " pos.Control`
     *
     * @returns {{Id: Integer, Control: String}} An object containing:
     * - `Id`: The unique ID of the window under the cursor.
     * - `Control`: The class name of the control under the cursor.
     */
    static Get() {
        MouseGetPos ,, &Id, &Control
        return { Id: Id, Control: Control }
    }

    /**
     * Attempts to set the keyboard focus to the control currently under the mouse cursor.
     * If the control cannot be found or focused (e.g., if it's not a focusable control),
     * a transient tooltip message is displayed.
     *
     * **AHK 2.0 Usage:**
     * `Mouse.FocusActive()` ; Call this to focus the control under the mouse.
     *
     * @returns {void}
     */
    static FocusActive() {
        try ControlFocus(this.Get().Control, this.Get().Id)
        catch {
            ; TimedTooltip is a placeholder for a user-defined function that displays a temporary message.
            ; A SetTimer with a negative period (-100ms) executes once after 100ms.
            Tooltip("Can't find control.", 2000)
        }
        return
    }

    class Move {

        static Pixel(Xdirection := 0, YDirection := 0 ) {
            MouseGetPos &firstX, &firstY
            MouseMove firstX + (Xdirection), firstY + (YDirection)
            return
        }

        static Monitor(maxScreens := 0) {
            MonitorCount := MonitorGetCount()

            ; Validation du param√®tre
            if (maxScreens > 0 && maxScreens > MonitorCount) {
                Tooltip "ERROR : Invalid screen value set. The code will execute for each monitor instead."
                Sleep 2000
                Tooltip ""
                maxScreens := 0  ; Revenir au comportement par d√©faut
            }
        
            ; Si un nombre de moniteurs sp√©cifique est demand√©
            max := (maxScreens > 0) ? maxScreens : MonitorCount
        
            CoordMode("Mouse", "Screen")
            MouseGetPos(&MouseX, &MouseY)
        
            ; Trouver sur quel √©cran on est
            current := 0
            Loop MonitorCount {
                MonitorGet(A_Index, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
                if ((MouseX >= MonitorLeft) && (MouseX < MonitorRight) && (MouseY >= MonitorTop) && (MouseY < MonitorBottom)) {
                    current := A_Index
                    currentRX := (MouseX - MonitorLeft) / (MonitorRight - MonitorLeft)
                    currentRY := (MouseY - MonitorTop) / (MonitorBottom - MonitorTop)
                    break
                }
            }
        
            ; Calcul de l'√©cran suivant
            next := current + 1
            if (next > max)
                next := 1
        
            ; Aller au centre du moniteur suivant
            MonitorGet(next, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
            newX := (MonitorLeft + MonitorRight) / 2
            newY := (MonitorTop + MonitorBottom) / 2

            ; D√©placement souris
            DllCall("SetCursorPos", "int", newX, "int", newY)
            Sleep 10
        }
    }
}

//// Terminal.ahk

    /**
     * @param {string} Title - The custom title for the Windows Terminal instance.
     * @param {string} Exe - The path to the Windows Terminal executable (e.g., 'wt.exe').
     * @param {Integer} [Position=3] - Screen position (1: Top-Left, 2: Top-Right, 3: Bottom-Left, 4: Bottom-Right).
     * @param {Integer} [Width=500] - The desired width of the window.
     * @param {Integer} [Height=300] - The desired height of the window.
     * @param {Integer} [CheckInterval=300] - Timer interval in ms to check focus.
     */
class Terminal {

    __new(title, exe, position := 3, width := 500, height := 300, checkInterval := 300) {
        ; Call the initialization function
        this.Init(title, exe, position, width, height, checkInterval)
    }

    /**
     * Initializes and positions the Windows Terminal window.
     * @private
     * @param {string} Title - The custom title for the Windows Terminal instance.
     * @param {string} Exe - The path to the Windows Terminal executable (e.g., 'wt.exe').
     * @param {Integer} Position - Screen position.
     * @param {Integer} Width - The desired width of the window.
     * @param {Integer} Height - The desired height of the window.
     * @param {Integer} CheckInterval - Timer interval in ms.
     */
    init(Title, Exe, Position, Width, Height, CheckInterval) {
        ; Check if the terminal window already exists
        this.hwnd := WinExist(Title)
        
        if (!this.hwnd) {
            ; Launch Windows Terminal with a custom title and PowerShell profile
            ; Note: Use backticks (`) for internal quoting in AHK v2 Run()
            Run(Format('{} -w 0 nt -p "PowerShell" --title `"{}"` ', Exe, Title))

            ; Wait for the window with the title to appear
            this.hwnd := WinWait(Title, , 5) ; Wait max 5 seconds
            
            if (!this.hwnd) {
                MsgBox("Failed to detect the Windows Terminal window.")
                return
            }
        }

        ; Get the primary screen size
        MonitorWidth := A_ScreenWidth
        MonitorHeight := A_ScreenHeight
        
        ; Calculate X and Y coordinates based on the Position parameter
        X := 0
        Y := 0
        
        if (Position = 1) { ; Top-Left
            X := 0
            Y := 0
        } else if (Position = 2) { ; Top-Right
            X := MonitorWidth - Width
            Y := 0
        } else if (Position = 3) { ; Bottom-Left
            X := 0
            Y := MonitorHeight - Height
        } else if (Position = 4) { ; Bottom-Right
            X := MonitorWidth - Width
            Y := MonitorHeight - Height
        } else {
            ; Invalid value, default to Bottom-Right
            X := MonitorWidth - Width
            Y := MonitorHeight - Height
        }

        ; Position and show the window
        WinShow "ahk_id " this.hwnd
        WinMove X, Y, Width, Height, "ahk_id " this.hwnd
        WinSetAlwaysOnTop True, "ahk_id " this.hwnd
        WinActivate "ahk_id " this.hwnd

        ; Start monitoring the focus
        SetTimer this.Watch.Bind(this), CheckInterval
    }

    /**
     * Minimizes the window if it loses focus. Used as a SetTimer function.
     * @private
     */
    watch() {
        ; Ensure the window still exists
        if (!WinExist("ahk_id " this.hwnd)) {
            ; Stop the timer if the window is gone
            SetTimer , 0
            return
        }

        ; Check if the window is no longer active
        if (WinActive("A") != this.hwnd) {
            WinMinimize "ahk_id " this.hwnd
            ; Stop the timer as the window is minimized
            SetTimer , 0
        }
    }
}

/**  Example Usage (Optional, for context)
@example 
Term := Terminal("MyCustomTerminalTitle", "wt.exe", 3, 500, 300, 300)
        ; OR
Terminal("MyCustomTerminalTitle", "wt.exe", 3, 500, 300, 300)
*/


//// Volume.ahk

#Requires AutoHotkey v2.0
#SingleInstance Force
/**
 * ```
 * Volume.Change(Action := '', ExeName := '', Value, ExePath := "")
 * ```
 * 
 * @Description - Can change, set or mute application sound volume using NirCmd utility.
 * 
 * @param {'Change'|'Set'|'Mute'} Action  -  Action to do on the app.
 * * `ChangeAppVolume` : Add/Subtract volume from specific app.
 * * `SetAppVolume` : Set precise volume for specific app.
 * * `MuteAppVolume` : Toggle mute for specific app.
 * 
 * @param {'{exeName}.exe'} ExeName  -  The Exe name.
 * 
 * @param {(Primitive)} Value
 * * Positive or Negative number between 0 and 1.
 * * Positive number increases the volume, Negative number decreases the volume.
 * 
 * @param {(String)} ExePath - A string param
 * 
 * @example 
 * ; Decrease Microsoft Edge volume by 2%.
 * Volume.Change("ChangeAppVolume", "msedge.exe", -0.02)
 * 
**/
class Volume {
    static Change(Action, ExeName, Value := "", ExePath := "Z:\Scripts\Tools\nircmd.exe") {
        try {
            Run('' ExePath ' ' Action ' ' ExeName ' ' Value '',, "Hide")
        } catch as e {
            return MsgBox('Error while trying to open "nircmd.exe".')  
        }   
    }

    /**
     * @class
     * Manages the launch, positioning, and sizing of the Windows Volume Mixer (SndVol.exe).
     * It uses WinWait and WinMove to control the target window.
     * * **CONFIGURATION**: All positioning parameters (MONITOR_INDEX, SndVol_WIDTH, etc.) 
     * are now passed directly to the Init() and Toggle() methods, making the behavior 
     * fully dynamic per call.
     * * @methods
     * Init() | Launches and positions the window based on provided parameters.
     * Toggle() | Closes the window if visible, or calls Init() with parameters if hidden.
     * * @example
     * ; Launches SndVol on monitor 2 (index 1), 600px wide, centered at the top.
     * ^s:: SndVol.Toggle(1, 600, 250, 50, 5)
     */
    class SndVol {
    
        ; --- WINDOW PROPERTIES ---
        ; The Title and Class of the target window (Volume Mixer)
        static WINDOW_TITLE := 'Volume Mixer'
        static WINDOW_CLASS := '#32770'
    
        /**
         * @static
         * **TOGGLE METHOD:** Closes the SndVol window if it is visible,
         * or calls Init() to launch and position it if it is not found.
         * * @param MONITOR_INDEX (Optional) The 0-based index of the target monitor. Defaults to 0 (primary).
         * @param SndVol_WIDTH (Optional) The desired width of the window. Defaults to 1000.
         * @param SndVol_HEIGHT (Optional) The desired height of the window. Defaults to 200.
         * @param SCREEN_MARGIN_EDGE (Optional) The margin (in pixels) from the monitor edge. Defaults to 80.
         * @param LOCATION (Optional) Code for positioning (1-8). Defaults to 5 (Top, Centered).
         * @returns True if the window was closed, False if it was launched.
         * * @example
         * SndVol.Toggle(1, 800, 200, 50, 8) ; Launch/Toggle on monitor 2, 800px wide, Bottom Centered (8).
         */
        static Toggle(MONITOR_INDEX := 0, SndVol_WIDTH := 1000, SndVol_HEIGHT := 200, SCREEN_MARGIN_EDGE := 80, LOCATION := 5) {
            ; Use partial title matching to ensure the window is found regardless of dynamic title changes.
            SetTitleMatchMode(2) 
        
            Local WindowTarget := this.WINDOW_TITLE ' ahk_class ' this.WINDOW_CLASS
            
            ; Checks if the window exists
            if (WinExist(WindowTarget)) {
                ; If the window exists, close it.
                WinClose(WindowTarget)
                Return True ; Indicates the window was closed
            } else {
                ; If the window doesn't exist, launch it via Init(), passing all current parameters.
                ; Note: 'this.Init()' is called, not 'Init()'.
                this.Init(MONITOR_INDEX, SndVol_WIDTH, SndVol_HEIGHT, SCREEN_MARGIN_EDGE, LOCATION)
                Return False ; Indicates the window was launched
            }
        }
    
        /**
         * @static
         * Launches SndVol.exe, waits for its window to appear, and then positions and sizes it
         * according to the provided parameters.
         * * @param MONITOR_INDEX The 0-based index of the target monitor.
         * @param SndVol_WIDTH The desired width of the window.
         * @param SndVol_HEIGHT The desired height of the window.
         * @param SCREEN_MARGIN_EDGE The margin (in pixels) from the monitor edge.
         * @param LOCATION Code for positioning (1-8).
         * @returns Nothing. Returns early on error (e.g., WinWait failure).
         * * @example
         * ; Launch SndVol on the primary monitor (0), Top-Left (1), with a 50px margin.
         * SndVol.Init(0, 500, 300, 50, 1)
         */
        static Init(MONITOR_INDEX, SndVol_WIDTH, SndVol_HEIGHT, SCREEN_MARGIN_EDGE, LOCATION) {
            ; * * LOCATION Codes:
            ; * 1: TopLeft, 2: TopRight, 3: BottomLeft, 4: BottomRight
            ; * 5: Top (Centered), 6: Left (Centered), 7: Right (Centered), 8: Bottom (Centered)
            
            SetTitleMatchMode(2) 
            
            ; 1. Launch SndVol.exe
            Run('SndVol.exe')
        
            ; 2. Wait for the Volume Mixer window to appear
            Local WindowTarget := this.WINDOW_TITLE ' ahk_class ' this.WINDOW_CLASS
            if (!WinWait(WindowTarget, , 5)) {
                MsgBox('Error: Could not find the "' this.WINDOW_TITLE '" window within 5 seconds.')
                return
            }
        
            ; 3. Calculate Monitor Coordinates (using WorkArea to exclude the taskbar)
            ; Monitor IDs are 1-based, so we add 1 to the 0-based MONITOR_INDEX.
            Local MonitorLeft, MonitorTop, MonitorRight, MonitorBottom
            try {
                MonitorGetWorkArea(MONITOR_INDEX + 1, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
            } catch {
                ; Fallback to the primary screen (Monitor ID 1) if the index is invalid
                MonitorGetWorkArea(1, &MonitorLeft, &MonitorTop, &MonitorRight, &MonitorBottom)
            }
            
            ; Fallback check...
            if (MonitorRight == '') {
                MsgBox('Error: Could not retrieve monitor dimensions.')
                return
            }
        
            ; 4. Calculate SndVol Window Position (X, Y)
            
            Local MonitorWidth := MonitorRight - MonitorLeft
            Local MonitorHeight := MonitorBottom - MonitorTop
        
            ; Adjust the window size if it exceeds monitor dimensions
            Local SndVol_WIDTH_Actual := SndVol_WIDTH, SndVol_HEIGHT_Actual := SndVol_HEIGHT
            
            if (SndVol_WIDTH_Actual > MonitorWidth) {
                SndVol_WIDTH_Actual := MonitorWidth
            }
            if (SndVol_HEIGHT_Actual > MonitorHeight) {
                SndVol_HEIGHT_Actual := MonitorHeight
            }
        
            Local Target_X := 0, Target_Y := 0
            
            ; --- Calculate X Coordinates ---
            if (LOCATION = 1 or LOCATION = 3) ; TopLeft or BottomLeft
                Target_X := MonitorLeft + SCREEN_MARGIN_EDGE
            else if (LOCATION = 2 or LOCATION = 4) ; TopRight or BottomRight
                Target_X := MonitorRight - SndVol_WIDTH_Actual - SCREEN_MARGIN_EDGE
            ; Centered X for Top/Bottom/Left/Right placements (5, 6, 7, 8)
            else
                Target_X := MonitorLeft + (MonitorWidth // 2) - (SndVol_WIDTH_Actual // 2)
            
            ; --- Calculate Y Coordinates ---
            if (LOCATION = 1 or LOCATION = 2 or LOCATION = 5) ; TopLeft, TopRight, Top (Centered)
                Target_Y := MonitorTop + SCREEN_MARGIN_EDGE
            else if (LOCATION = 3 or LOCATION = 4 or LOCATION = 8) ; BottomLeft, BottomRight, Bottom (Centered)
                Target_Y := MonitorBottom - SndVol_HEIGHT_Actual - SCREEN_MARGIN_EDGE
            ; Centered Y for Left/Right placements (6, 7)
            else if (LOCATION = 6 or LOCATION = 7)
                Target_Y := MonitorTop + (MonitorHeight // 2) - (SndVol_HEIGHT_Actual // 2)
            
            ; 5. Position and Size the Window
            ; A second WinWait is sometimes needed to ensure the window is ready for WinMove/Activate
            WinWait(WindowTarget, , 5)
            Sleep 100
            WinMove(Target_X, Target_Y, SndVol_WIDTH_Actual, SndVol_HEIGHT_Actual, WindowTarget)
            
            ; 6. Ensure the window is active and visible
            WinActivate(WindowTarget)
        }
    }
}


//// WaitForUserConfirm.ahk

#Requires AutoHotkey v2.0

WaitForUserConfirm(keys*) {
    ; keys* est un array des touches √† surveiller
    while true {
        for key in keys {
            if GetKeyState(key, "P") {
                SendInput "{" key " Up}"
                SendInput "{LButton Up}"
                Tooltip
                sleep 10
                return key ; Retourne la touche utilis√©e
            }
        }
        Tooltip "PRESS " JoinArray(keys) " `nWHEN DONE"
        Sleep 10
    }
}

//// Window.ahk

#Requires AutoHotkey v2.0

/**
 * @class
 * @description Provides static methods for window management (Move, Resize).
 */
class Window {
    /**
     * Moves the active window by dragging.
     * @param {string} MouseButton The mouse button to monitor for dragging (e.g., "LButton", "RButton").
     */
    static Move(MouseButton)
    {
        try {
            hold := 0
            CoordMode "Mouse"
            ; Get the initial mouse position and window id
            MouseGetPos &KDE_X1, &KDE_Y1, &KDE_id
            ; Get the initial window position and size.
            WinGetPos &KDE_WinX1, &KDE_WinY1, &KDE_WinW, &KDE_WinH, KDE_id
            sleep(1)

            ; Define the window region the mouse is currently in (unused for basic move, but kept for context).
            ; The four regions are Up and Left, Up and Right, Down and Left, Down and Right.
            if (KDE_X1 < KDE_WinX1 + KDE_WinW / 2)
                KDE_WinLeft := 1
            else
                KDE_WinLeft := -1
            if (KDE_Y1 < KDE_WinY1 + KDE_WinH / 2)
                KDE_WinUp := 1
            else
                KDE_WinUp := -1

            if GetKeyState(MouseButton, "P")
                Loop
                {
                    hold++
                    if !GetKeyState(MouseButton, "P") ; Break if button has been released.
                        break
                    WinActivate KDE_id
                    MouseGetPos &KDE_X2, &KDE_Y2 ; Get the current mouse position.
                    KDE_X2 -= KDE_X1 ; Obtain an offset from the initial mouse position.
                    KDE_Y2 -= KDE_Y1
                    KDE_WinX2 := (KDE_WinX1 + KDE_X2) ; Apply this offset to the window X position.
                    KDE_WinY2 := (KDE_WinY1 + KDE_Y2) ; Apply this offset to the window Y position.
                    WinMove KDE_WinX2, KDE_WinY2,,, KDE_id ; Move the window to the new position.
                }


            if hold < 6 {
                SendInput "{" MouseButton "}"
            }

            return

        } catch {
            tooltip "Failed moving window."
            return
        }

    }

    /**
     * Resizes the active window based on the mouse position relative to the center.
     * @param {string} MouseButton The mouse button to monitor for dragging (e.g., "LButton", "RButton").
     */
    static Resize(MouseButton)
    {
        CoordMode "Mouse"
        ; Get the initial mouse position and window id.
        MouseGetPos &KDE_X1, &KDE_Y1, &KDE_id
        ; Abort if the window is maximized.
        if WinGetMinMax(KDE_id)
            return
        ; Get the initial window position and size.
        WinGetPos &KDE_WinX1, &KDE_WinY1, &KDE_WinW, &KDE_WinH, KDE_id
        ; Define the window region the mouse is currently in.
        ; The four regions are Up and Left, Up and Right, Down and Left, Down and Right.
        if (KDE_X1 < KDE_WinX1 + KDE_WinW / 2)
            KDE_WinLeft := 1
        else
            KDE_WinLeft := -1
        if (KDE_Y1 < KDE_WinY1 + KDE_WinH / 2)
            KDE_WinUp := 1
        else
            KDE_WinUp := -1

        Loop
        {
            if !GetKeyState(MouseButton, "P") ; Break if button has been released.
                break
            MouseGetPos &KDE_X2, &KDE_Y2 ; Get the current mouse position.
            ; Get the current window position and size (important for continuous adjustment).
            WinGetPos &KDE_WinX1, &KDE_WinY1, &KDE_WinW, &KDE_WinH, KDE_id
            KDE_X2 -= KDE_X1 ; Obtain an offset from the initial mouse position.
            KDE_Y2 -= KDE_Y1
            ; Then, act according to the defined region to resize.
            WinMove KDE_WinX1 + (KDE_WinLeft+1)/2*KDE_X2  ; X of resized window (moves only if left region)
                  , KDE_WinY1 +    (KDE_WinUp+1)/2*KDE_Y2  ; Y of resized window (moves only if top region)
                  , KDE_WinW  -      KDE_WinLeft  *KDE_X2  ; W of resized window (adds/subtracts based on left/right region)
                  , KDE_WinH  -        KDE_WinUp  *KDE_Y2  ; H of resized window (adds/subtracts based on top/bottom region)
                  , KDE_id
            KDE_X1 := (KDE_X2 + KDE_X1) ; Reset the initial X position for the next iteration.
            KDE_Y1 := (KDE_Y2 + KDE_Y1) ; Reset the initial Y position for the next iteration.
        }
    }


}

//// RichEdit.ahk
//// RichEditDlgs.ahk
//// RichEditSample.ahk
